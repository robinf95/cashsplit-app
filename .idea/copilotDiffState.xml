<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.gitignore">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.gitignore" />
              <option name="originalContent" value="/node_modules&#10;.vercel&#10;" />
              <option name="updatedContent" value="/node_modules&#10;.vercel&#10;&#10;# Environment variables&#10;.env&#10;.env.local&#10;.env.development.local&#10;.env.test.local&#10;.env.production.local&#10;&#10;# Build outputs&#10;dist/&#10;&#10;# IDE&#10;.vscode/&#10;.idea/&#10;&#10;# OS&#10;.DS_Store&#10;Thumbs.db" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/api/_db.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/api/_db.ts" />
              <option name="originalContent" value="import { createPool } from '@vercel/postgres'&#10;export const pool=createPool()&#10;" />
              <option name="updatedContent" value="import { createPool } from '@vercel/postgres'&#10;import { createClient } from '@supabase/supabase-js'&#10;&#10;// Vercel Postgres pool for server-side operations&#10;export const pool = createPool()&#10;&#10;// Supabase client for server-side operations with service role&#10;const supabaseUrl = process.env.SUPABASE_URL || process.env.NEXT_PUBLIC_SUPABASE_URL!&#10;const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY!&#10;&#10;export const supabaseAdmin = createClient(supabaseUrl, supabaseServiceKey, {&#10;  auth: {&#10;    autoRefreshToken: false,&#10;    persistSession: false&#10;  }&#10;})&#10;&#10;// Regular Supabase client for server-side operations&#10;const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!&#10;export const supabase = createClient(supabaseUrl, supabaseAnonKey)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/db/schema.sql">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/db/schema.sql" />
              <option name="originalContent" value="create extension if not exists pgcrypto;&#10;create table if not exists groups (&#10;  id uuid primary key,&#10;  user_id text not null,&#10;  name text not null,&#10;  currency text not null default 'EUR',&#10;  id uuid primary key,&#10;  id uuid primary key,&#10;  id uuid primary key,&#10;  id uuid primary key,&#10;  payer text not null,&#10;  for_members text[] not null,&#10;  note text,&#10;  date timestamptz not null default now(),&#10;  currency text&#10;);" />
              <option name="updatedContent" value="create extension if not exists pgcrypto;&#10;create table if not exists groups (&#10;  id uuid primary key default gen_random_uuid(),&#10;  user_id text not null,&#10;  name text not null,&#10;  currency text not null default 'EUR',&#10;  members text[] not null default '{}',&#10;  created_at timestamptz not null default now()&#10;);&#10;create table if not exists expenses (&#10;  id uuid primary key default gen_random_uuid(),&#10;  user_id text not null,&#10;  group_id uuid not null references groups(id) on delete cascade,&#10;  amount numeric(12,2) not null check (amount &gt;= 0),&#10;  payer text not null,&#10;  for_members text[] not null,&#10;  note text,&#10;  date timestamptz not null default now(),&#10;  currency text&#10;);&#10;create table if not exists user_settings (&#10;  user_id text primary key,&#10;  exchange_rates jsonb default '{}',&#10;  base_currency text default 'EUR',&#10;  updated_at timestamptz not null default now()&#10;);" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/App.vue">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/App.vue" />
              <option name="originalContent" value="&lt;script setup lang=&quot;ts&quot;&gt;&#10;import { onMounted, ref, watch } from 'vue'&#10;import { useExpenseStore } from './stores/expenses'&#10;&#10;const clerk: any = (window as any).Clerk&#10;const user = ref&lt;any&gt;(null)&#10;const expenseStore = useExpenseStore()&#10;onMounted(async () =&gt; {&#10;onMounted(async () =&gt; {&#10;  try {&#10;&#10;&#10;    // Initialize the store after mounting&#10;    await expenseStore.initialize()&#10;  } catch {}&#10;const signOut = async () =&gt; {&#10;const signOut = async () =&gt; {&#10;// Watch for user changes and reinitialize store&#10;watch(user, async (newUser) =&gt; {&#10;  if (newUser) {&#10;    await expenseStore.initialize()&#10;  } else {&#10;    // Clear store when user signs out&#10;    expenseStore.$reset()&#10;" />
              <option name="updatedContent" value="&lt;script setup lang=&quot;ts&quot;&gt;&#10;import { onMounted, ref, watch } from 'vue'&#10;import { useExpenseStore } from './stores/expenses'&#10;&#10;const clerk: any = (window as any).Clerk&#10;const user = ref&lt;any&gt;(null)&#10;const expenseStore = useExpenseStore()&#10;let isInitialized = false&#10;&#10;onMounted(async () =&gt; { &#10;  try { &#10;    user.value = await clerk.user?.reload?.() || clerk.user&#10;    &#10;    // Initialize the store only once after mounting&#10;    if (!isInitialized) {&#10;      await expenseStore.initialize()&#10;      isInitialized = true&#10;    }&#10;  } catch (error) {&#10;    console.error('Error during app initialization:', error)&#10;    // Initialize store even on error to provide demo data&#10;    if (!isInitialized) {&#10;      await expenseStore.initialize()&#10;      isInitialized = true&#10;    }&#10;  }&#10;})&#10;&#10;// Watch for user changes and reinitialize store only when needed&#10;watch(user, async (newUser, oldUser) =&gt; {&#10;  // Only reinitialize if user actually changed (not just initial load)&#10;  if (oldUser !== undefined &amp;&amp; newUser?.id !== oldUser?.id) {&#10;    if (newUser) {&#10;      await expenseStore.initialize()&#10;    } else {&#10;      // Clear store when user signs out&#10;      expenseStore.$reset()&#10;      isInitialized = false&#10;    }&#10;  }&#10;}, { immediate: false })&#10;&#10;const signOut = async () =&gt; { &#10;  await clerk.signOut()&#10;  location.href = '/signin' &#10;}&#10;&#10;const openSignIn = async () =&gt; { &#10;  await clerk.openSignIn() &#10;}&#10;&lt;/script&gt;&#10;&#10;&lt;template&gt;&#10;  &lt;main class=&quot;min-h-screen max-w-xl mx-auto p-4 sm:p-6&quot;&gt;&#10;    &lt;header class=&quot;flex items-center justify-between mb-4&quot;&gt;&#10;      &lt;h1 class=&quot;text-2xl font-semibold tracking-tight&quot;&gt; CashSplit&lt;/h1&gt;&#10;      &lt;div class=&quot;flex items-center gap-3&quot;&gt;&#10;        &lt;span v-if=&quot;user&quot; class=&quot;text-xs text-gray-600 dark:text-gray-300&quot;&gt;Hi, {{ user.firstName || user.username }}&lt;/span&gt;&#10;        &lt;button v-if=&quot;user&quot; class=&quot;text-sm underline&quot; @click=&quot;signOut&quot;&gt;Logout&lt;/button&gt;&#10;        &lt;button v-else class=&quot;text-sm underline&quot; @click=&quot;openSignIn&quot;&gt;Login&lt;/button&gt;&#10;      &lt;/div&gt;&#10;    &lt;/header&gt;&#10;    &lt;router-view /&gt;&#10;    &lt;footer class=&quot;mt-8 text-center text-xs text-gray-500 dark:text-gray-400&quot;&gt;&#10;      Built with Vue &amp; Tailwind • Vercel Functions + Postgres • PWA&#10;    &lt;/footer&gt;&#10;  &lt;/main&gt;&#10;&lt;/template&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/GroupSelect.vue">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/GroupSelect.vue" />
              <option name="originalContent" value="&lt;script setup lang=&quot;ts&quot;&gt;&#10;import { ref } from 'vue'&#10;import { useRouter } from 'vue-router'&#10;import { useExpenseStore, type Currency } from '../stores/expenses'&#10;&#10;const s = useExpenseStore()&#10;const router = useRouter()&#10;const groupName = ref('')&#10;const memberNames = ref('Alice,Bob')&#10;const currency = ref&lt;Currency&gt;('EUR')&#10;&#10;async function create() {&#10;  const members = memberNames.value.split(',').map(x=&gt;x.trim()).filter(Boolean)&#10;  if (!groupName.value || members.length &lt; 1) return&#10;&#10;  try {&#10;    await s.addGroup(groupName.value, members, currency.value)&#10;    // Now get the ID from the last group that was actually added&#10;    const newGroup = s.groups[s.groups.length-1]&#10;    if (newGroup?.id) {&#10;      router.push(`/groups/${newGroup.id}`)&#10;    }&#10;  } catch (error) {&#10;    console.error('Failed to create group:', error)&#10;    // Show error to user or handle gracefully&#10;  }&#10;}&#10;&#10;async function deleteGroup(groupId: string, groupName: string) {&#10;  if (confirm(`Möchten Sie die Gruppe &quot;${groupName}&quot; wirklich löschen? Alle zugehörigen Ausgaben werden ebenfalls gelöscht.`)) {&#10;    try {&#10;      await s.deleteGroup(groupId)&#10;      // If we're currently viewing this group, redirect to home&#10;      if (router.currentRoute.value.params.id === groupId) {&#10;        router.push('/')&#10;      }&#10;    } catch (error) {&#10;      console.error('Failed to delete group:', error)&#10;      alert('Fehler beim Löschen der Gruppe')&#10;    }&#10;  }&#10;}&#10;&lt;/script&gt;&#10;&#10;&lt;template&gt;&#10;  &lt;section class=&quot;grid gap-4&quot;&gt;&#10;    &lt;div class=&quot;card&quot;&gt;&#10;      &lt;h2 class=&quot;text-lg font-semibold mb-2&quot;&gt;Gruppen&lt;/h2&gt;&#10;      &lt;ul class=&quot;divide-y divide-gray-200 dark:divide-gray-700&quot;&gt;&#10;        &lt;li v-for=&quot;g in s.groups&quot; :key=&quot;g.id&quot; class=&quot;py-2 flex items-center justify-between&quot;&gt;&#10;          &lt;div&gt;&#10;            &lt;div class=&quot;font-medium&quot;&gt;{{ g.name }}&lt;/div&gt;&#10;            &lt;div class=&quot;text-xs text-gray-500&quot;&gt;{{ g.members.join(', ') }} · {{ g.currency }}&lt;/div&gt;&#10;          &lt;/div&gt;&#10;          &lt;div class=&quot;flex gap-2&quot;&gt;&#10;            &lt;router-link :to=&quot;`/groups/${g.id}`&quot; class=&quot;btn-primary&quot;&gt;Öffnen&lt;/router-link&gt;&#10;            &lt;button&#10;              @click=&quot;deleteGroup(g.id, g.name)&quot;&#10;              class=&quot;btn-secondary text-red-600 hover:bg-red-50 hover:text-red-700 dark:hover:bg-red-900/20&quot;&#10;              title=&quot;Gruppe löschen&quot;&#10;            &gt;&#10;              Löschen&#10;&#10;    &lt;div class=&quot;card&quot;&gt;&#10;      &lt;h2 class=&quot;text-lg font-semibold mb-2&quot;&gt;Neue Gruppe&lt;/h2&gt;&#10;      &lt;div class=&quot;grid gap-2&quot;&gt;&#10;        &lt;label class=&quot;label&quot;&gt;Name&lt;/label&gt;&#10;        &lt;input v-model=&quot;groupName&quot; class=&quot;input&quot; placeholder=&quot;z. B. Kreta 2025&quot; /&gt;&#10;        &lt;label class=&quot;label&quot;&gt;Mitglieder (Kommagetrennt)&lt;/label&gt;&#10;        &lt;input v-model=&quot;memberNames&quot; class=&quot;input&quot; /&gt;&#10;        &lt;label class=&quot;label&quot;&gt;Währung&lt;/label&gt;&#10;        &lt;select v-model=&quot;currency&quot; class=&quot;input&quot;&gt;&#10;          &lt;option&gt;EUR&lt;/option&gt;&lt;option&gt;USD&lt;/option&gt;&lt;option&gt;CHF&lt;/option&gt;&lt;option&gt;GBP&lt;/option&gt;&#10;        &lt;/select&gt;&#10;        &lt;button @click=&quot;create&quot; class=&quot;btn-primary mt-2&quot;&gt;Erstellen&lt;/button&gt;&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  &lt;/section&gt;&#10;&lt;/template&gt;" />
              <option name="updatedContent" value="&lt;script setup lang=&quot;ts&quot;&gt;&#10;import { ref } from 'vue'&#10;import { useRouter } from 'vue-router'&#10;import { useExpenseStore, type Currency } from '../stores/expenses'&#10;&#10;const s = useExpenseStore()&#10;const router = useRouter()&#10;const groupName = ref('')&#10;const memberNames = ref('Alice,Bob')&#10;const currency = ref&lt;Currency&gt;('EUR')&#10;&#10;async function create() {&#10;  const members = memberNames.value.split(',').map(x=&gt;x.trim()).filter(Boolean)&#10;  if (!groupName.value || members.length &lt; 1) return&#10;&#10;  try {&#10;    await s.addGroup(groupName.value, members, currency.value)&#10;    // Now get the ID from the last group that was actually added&#10;    const newGroup = s.groups[s.groups.length-1]&#10;    if (newGroup?.id) {&#10;      router.push(`/groups/${newGroup.id}`)&#10;    }&#10;  } catch (error) {&#10;    console.error('Failed to create group:', error)&#10;    // Show error to user or handle gracefully&#10;  }&#10;}&#10;&#10;async function deleteGroup(groupId: string, groupName: string) {&#10;  if (confirm(`Möchten Sie die Gruppe &quot;${groupName}&quot; wirklich löschen? Alle zugehörigen Ausgaben werden ebenfalls gelöscht.`)) {&#10;    try {&#10;      await s.deleteGroup(groupId)&#10;      // If we're currently viewing this group, redirect to home&#10;      if (router.currentRoute.value.params.id === groupId) {&#10;        router.push('/')&#10;      }&#10;    } catch (error) {&#10;      console.error('Failed to delete group:', error)&#10;      alert('Fehler beim Löschen der Gruppe')&#10;    }&#10;  }&#10;}&#10;&lt;/script&gt;&#10;&#10;&lt;template&gt;&#10;  &lt;section class=&quot;grid gap-4&quot;&gt;&#10;    &lt;div class=&quot;card&quot;&gt;&#10;      &lt;h2 class=&quot;text-lg font-semibold mb-2&quot;&gt;Gruppen&lt;/h2&gt;&#10;      &lt;ul class=&quot;divide-y divide-gray-200 dark:divide-gray-700&quot;&gt;&#10;        &lt;li v-for=&quot;g in s.groups&quot; :key=&quot;g.id&quot; class=&quot;py-2 flex items-center justify-between&quot;&gt;&#10;          &lt;div&gt;&#10;            &lt;div class=&quot;font-medium&quot;&gt;{{ g.name }}&lt;/div&gt;&#10;            &lt;div class=&quot;text-xs text-gray-500&quot;&gt;{{ g.members.join(', ') }} · {{ g.currency }}&lt;/div&gt;&#10;          &lt;/div&gt;&#10;          &lt;div class=&quot;flex gap-2&quot;&gt;&#10;            &lt;router-link :to=&quot;`/groups/${g.id}`&quot; class=&quot;btn-primary&quot;&gt;Öffnen&lt;/router-link&gt;&#10;            &lt;button &#10;              @click=&quot;deleteGroup(g.id, g.name)&quot; &#10;              class=&quot;btn-secondary text-red-600 hover:bg-red-50 hover:text-red-700 dark:hover:bg-red-900/20 p-2&quot;&#10;              title=&quot;Gruppe löschen&quot;&#10;            &gt;&#10;              &lt;svg width=&quot;16&quot; height=&quot;16&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; stroke=&quot;currentColor&quot; stroke-width=&quot;2&quot; stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot;&gt;&#10;                &lt;polyline points=&quot;3,6 5,6 21,6&quot;&gt;&lt;/polyline&gt;&#10;                &lt;path d=&quot;m19,6v14a2,2 0 0,1 -2,2H7a2,2 0 0,1 -2,-2V6m3,0V4a2,2 0 0,1 2,-2h4a2,2 0 0,1 2,2v2&quot;&gt;&lt;/path&gt;&#10;                &lt;line x1=&quot;10&quot; y1=&quot;11&quot; x2=&quot;10&quot; y2=&quot;17&quot;&gt;&lt;/line&gt;&#10;                &lt;line x1=&quot;14&quot; y1=&quot;11&quot; x2=&quot;14&quot; y2=&quot;17&quot;&gt;&lt;/line&gt;&#10;              &lt;/svg&gt;&#10;            &lt;/button&gt;&#10;          &lt;/div&gt;&#10;        &lt;/li&gt;&#10;      &lt;/ul&gt;&#10;    &lt;/div&gt;&#10;&#10;    &lt;div class=&quot;card&quot;&gt;&#10;      &lt;h2 class=&quot;text-lg font-semibold mb-2&quot;&gt;Neue Gruppe&lt;/h2&gt;&#10;      &lt;div class=&quot;grid gap-2&quot;&gt;&#10;        &lt;label class=&quot;label&quot;&gt;Name&lt;/label&gt;&#10;        &lt;input v-model=&quot;groupName&quot; class=&quot;input&quot; placeholder=&quot;z. B. Kreta 2025&quot; /&gt;&#10;        &lt;label class=&quot;label&quot;&gt;Mitglieder (Kommagetrennt)&lt;/label&gt;&#10;        &lt;input v-model=&quot;memberNames&quot; class=&quot;input&quot; /&gt;&#10;        &lt;label class=&quot;label&quot;&gt;Währung&lt;/label&gt;&#10;        &lt;select v-model=&quot;currency&quot; class=&quot;input&quot;&gt;&#10;          &lt;option&gt;EUR&lt;/option&gt;&lt;option&gt;USD&lt;/option&gt;&lt;option&gt;CHF&lt;/option&gt;&lt;option&gt;GBP&lt;/option&gt;&#10;        &lt;/select&gt;&#10;        &lt;button @click=&quot;create&quot; class=&quot;btn-primary mt-2&quot;&gt;Erstellen&lt;/button&gt;&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  &lt;/section&gt;&#10;&lt;/template&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/SettleSuggestions.vue">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/SettleSuggestions.vue" />
              <option name="originalContent" value="&lt;script setup lang=&quot;ts&quot;&gt;&#10;import { computed } from 'vue'&#10;import { useExpenseStore } from '../stores/expenses'&#10;&#10;const props = defineProps&lt;{ groupId: string }&gt;()&#10;const s = useExpenseStore()&#10;const settlements = computed(() =&gt; s.settlements(props.groupId))&#10;const g = computed(() =&gt; s.groupById(props.groupId))&#10;&lt;/script&gt;&#10;&#10;&lt;template&gt;&#10;  &lt;div class=&quot;card&quot;&gt;&#10;    &lt;h3 class=&quot;text-lg font-semibold mb-2&quot;&gt;Ausgleichsvorschläge&lt;/h3&gt;&#10;    &lt;div v-if=&quot;settlements.length === 0&quot; class=&quot;text-sm text-gray-500&quot;&gt;&#10;      Keine Ausgleichszahlungen nötig.&#10;    &lt;/div&gt;&#10;    &lt;ul class=&quot;space-y-2&quot;&gt;&#10;      &lt;li v-for=&quot;(t, i) in settlements&quot; :key=&quot;i&quot; class=&quot;flex items-center justify-between&quot;&gt;&#10;        &lt;div class=&quot;text-sm&quot;&gt;&#10;          &lt;b&gt;{{ t.from }}&lt;/b&gt; → &lt;b&gt;{{ t.to }}&lt;/b&gt;&#10;        &lt;/div&gt;&#10;        &lt;div class=&quot;font-medium&quot;&gt;{{ t.amount.toFixed(2) }} {{ g?.currency }}&lt;/div&gt;&#10;      &lt;/li&gt;&#10;    &lt;/ul&gt;&#10;  &lt;/div&gt;&#10;&lt;/template&gt;" />
              <option name="updatedContent" value="&lt;script setup lang=&quot;ts&quot;&gt;&#10;import { computed, ref } from 'vue'&#10;import { useExpenseStore } from '../stores/expenses'&#10;&#10;interface Props {&#10;  groupId: string&#10;}&#10;&#10;const props = defineProps&lt;Props&gt;()&#10;const store = useExpenseStore()&#10;const isSettling = ref(false)&#10;const showSuccessMessage = ref(false)&#10;&#10;// Get settlements for this group&#10;const settlements = computed(() =&gt; store.settlements(props.groupId))&#10;&#10;// Get group currency&#10;const groupCurrency = computed(() =&gt; {&#10;  const group = store.groupById(props.groupId)&#10;  return group?.currency || 'EUR'&#10;})&#10;&#10;// Settle all payments by creating balancing expenses&#10;const settleAllPayments = async () =&gt; {&#10;  if (settlements.value.length === 0) return&#10;  &#10;  isSettling.value = true&#10;  showSuccessMessage.value = false&#10;  &#10;  try {&#10;    const currentDate = new Date().toISOString().split('T')[0]&#10;    &#10;    // Create settlement expenses for each required payment&#10;    for (const settlement of settlements.value) {&#10;      await store.addExpense({&#10;        groupId: props.groupId,&#10;        payer: settlement.from,&#10;        for: [settlement.to],&#10;        amount: settlement.amount,&#10;        note: `Ausgleichszahlung: ${settlement.from} → ${settlement.to}`,&#10;        date: currentDate,&#10;        currency: groupCurrency.value&#10;      })&#10;    }&#10;    &#10;    // Show success message&#10;    showSuccessMessage.value = true&#10;    &#10;    // Hide success message after 3 seconds&#10;    setTimeout(() =&gt; {&#10;      showSuccessMessage.value = false&#10;    }, 3000)&#10;    &#10;  } catch (error) {&#10;    console.error('Error settling payments:', error)&#10;    alert('Fehler beim Ausgleichen der Zahlungen. Bitte versuchen Sie es erneut.')&#10;  } finally {&#10;    isSettling.value = false&#10;  }&#10;}&#10;&lt;/script&gt;&#10;&#10;&lt;template&gt;&#10;  &lt;div v-if=&quot;settlements.length &gt; 0&quot; class=&quot;mt-6 p-4 bg-blue-50 rounded-lg border border-blue-200&quot;&gt;&#10;    &lt;h3 class=&quot;text-lg font-semibold text-blue-900 mb-3&quot;&gt;&#10;       Ausgleichsvorschläge&#10;    &lt;/h3&gt;&#10;    &#10;    &lt;div class=&quot;space-y-2 mb-4&quot;&gt;&#10;      &lt;div &#10;        v-for=&quot;settlement in settlements&quot; &#10;        :key=&quot;`${settlement.from}-${settlement.to}`&quot;&#10;        class=&quot;flex items-center justify-between p-3 bg-white rounded border&quot;&#10;      &gt;&#10;        &lt;div class=&quot;flex items-center space-x-2&quot;&gt;&#10;          &lt;span class=&quot;font-medium text-gray-700&quot;&gt;{{ settlement.from }}&lt;/span&gt;&#10;          &lt;span class=&quot;text-gray-500&quot;&gt;→&lt;/span&gt;&#10;          &lt;span class=&quot;font-medium text-gray-700&quot;&gt;{{ settlement.to }}&lt;/span&gt;&#10;        &lt;/div&gt;&#10;        &lt;div class=&quot;font-bold text-green-600&quot;&gt;&#10;          {{ settlement.amount.toFixed(2) }} {{ groupCurrency }}&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;&#10;    &lt;div class=&quot;flex items-center justify-between pt-3 border-t border-blue-200&quot;&gt;&#10;      &lt;div class=&quot;text-sm text-blue-700&quot;&gt;&#10;        {{ settlements.length }} Überweisung{{ settlements.length !== 1 ? 'en' : '' }} erforderlich&#10;      &lt;/div&gt;&#10;      &#10;      &lt;button&#10;        @click=&quot;settleAllPayments&quot;&#10;        :disabled=&quot;isSettling&quot;&#10;        class=&quot;px-4 py-2 bg-green-600 text-white font-medium rounded-lg hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed transition-colors&quot;&#10;      &gt;&#10;        &lt;span v-if=&quot;isSettling&quot; class=&quot;flex items-center&quot;&gt;&#10;          &lt;svg class=&quot;animate-spin -ml-1 mr-2 h-4 w-4 text-white&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; fill=&quot;none&quot; viewBox=&quot;0 0 24 24&quot;&gt;&#10;            &lt;circle class=&quot;opacity-25&quot; cx=&quot;12&quot; cy=&quot;12&quot; r=&quot;10&quot; stroke=&quot;currentColor&quot; stroke-width=&quot;4&quot;&gt;&lt;/circle&gt;&#10;            &lt;path class=&quot;opacity-75&quot; fill=&quot;currentColor&quot; d=&quot;M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z&quot;&gt;&lt;/path&gt;&#10;          &lt;/svg&gt;&#10;          Wird ausgeglichen...&#10;        &lt;/span&gt;&#10;        &lt;span v-else&gt;&#10;           Alle Zahlungen ausgleichen&#10;        &lt;/span&gt;&#10;      &lt;/button&gt;&#10;    &lt;/div&gt;&#10;&#10;    &lt;!-- Success Message --&gt;&#10;    &lt;div v-if=&quot;showSuccessMessage&quot; class=&quot;mt-3 p-3 bg-green-100 border border-green-300 rounded-lg&quot;&gt;&#10;      &lt;div class=&quot;flex items-center&quot;&gt;&#10;        &lt;svg class=&quot;h-5 w-5 text-green-500 mr-2&quot; fill=&quot;currentColor&quot; viewBox=&quot;0 0 20 20&quot;&gt;&#10;          &lt;path fill-rule=&quot;evenodd&quot; d=&quot;M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z&quot; clip-rule=&quot;evenodd&quot;/&gt;&#10;        &lt;/svg&gt;&#10;        &lt;span class=&quot;text-green-800 font-medium&quot;&gt;&#10;          Alle Gruppenzahlungen wurden erfolgreich ausgeglichen!&#10;        &lt;/span&gt;&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  &lt;/div&gt;&#10;&#10;  &lt;div v-else class=&quot;mt-6 p-4 bg-green-50 rounded-lg border border-green-200&quot;&gt;&#10;    &lt;div class=&quot;flex items-center&quot;&gt;&#10;      &lt;svg class=&quot;h-5 w-5 text-green-500 mr-2&quot; fill=&quot;currentColor&quot; viewBox=&quot;0 0 20 20&quot;&gt;&#10;        &lt;path fill-rule=&quot;evenodd&quot; d=&quot;M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z&quot; clip-rule=&quot;evenodd&quot;/&gt;&#10;      &lt;/svg&gt;&#10;      &lt;span class=&quot;text-green-800 font-medium&quot;&gt;&#10;        ✅ Alle Gruppenzahlungen sind bereits ausgeglichen!&#10;      &lt;/span&gt;&#10;    &lt;/div&gt;&#10;  &lt;/div&gt;&#10;&lt;/template&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/lib/supabase-service.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/lib/supabase-service.ts" />
              <option name="originalContent" value="import { supabase } from '../lib/supabase'&#10;&#10;// Database types for better TypeScript support&#10;export interface Group {&#10;  id: string&#10;  user_id: string&#10;  name: string&#10;  currency: string&#10;  members: string[]&#10;  created_at: string&#10;}&#10;&#10;export interface Expense {&#10;  id: string&#10;  user_id: string&#10;  group_id: string&#10;  amount: number&#10;  payer: string&#10;  for_members: string[]&#10;  note?: string&#10;  date: string&#10;  currency?: string&#10;}&#10;&#10;// Client-side database operations using Supabase&#10;export class SupabaseService {&#10;  // Groups operations&#10;  static async getGroups(userId: string): Promise&lt;Group[]&gt; {&#10;    const { data, error } = await supabase&#10;      .from('groups')&#10;      .select('id, user_id, name, currency, members, created_at')&#10;      .eq('user_id', userId)&#10;      .order('created_at', { ascending: false })&#10;&#10;    if (error) throw error&#10;    return data || []&#10;  }&#10;&#10;  static async createGroup(userId: string, name: string, currency: string = 'EUR', members: string[] = []): Promise&lt;string&gt; {&#10;    const { data, error } = await supabase&#10;      .from('groups')&#10;      .insert([{ user_id: userId, name, currency, members }])&#10;      .select('id')&#10;      .single()&#10;    &#10;    if (error) throw error&#10;    return data.id&#10;  }&#10;&#10;  static async updateGroup(groupId: string, userId: string, updates: { name?: string; currency?: string }): Promise&lt;void&gt; {&#10;    const { error } = await supabase&#10;      .from('groups')&#10;      .update(updates)&#10;      .eq('id', groupId)&#10;      .eq('user_id', userId)&#10;&#10;    if (error) throw error&#10;  }&#10;&#10;  static async deleteGroup(groupId: string, userId: string): Promise&lt;void&gt; {&#10;    const { error } = await supabase&#10;      .from('groups')&#10;      .delete()&#10;      .eq('id', groupId)&#10;      .eq('user_id', userId)&#10;    &#10;    if (error) throw error&#10;  }&#10;&#10;  // Expenses operations&#10;  static async getExpenses(groupId: string): Promise&lt;Expense[]&gt; {&#10;    const { data, error } = await supabase&#10;      .from('expenses')&#10;      .select('*')&#10;      .eq('group_id', groupId)&#10;      .order('date', { ascending: false })&#10;    &#10;    if (error) throw error&#10;    return data || []&#10;  }&#10;&#10;  static async createExpense(expense: Omit&lt;Expense, 'id' | 'date'&gt;): Promise&lt;string&gt; {&#10;    const { data, error } = await supabase&#10;      .from('expenses')&#10;      .insert([{ ...expense, date: new Date().toISOString() }])&#10;      .select('id')&#10;      .single()&#10;    &#10;    if (error) throw error&#10;    return data.id&#10;  }&#10;&#10;  static async deleteExpense(expenseId: string, userId: string): Promise&lt;void&gt; {&#10;    const { error } = await supabase&#10;      .from('expenses')&#10;      .delete()&#10;      .eq('id', expenseId)&#10;      .eq('user_id', userId)&#10;    &#10;    if (error) throw error&#10;  }&#10;&#10;  // Real-time subscriptions&#10;  static subscribeToGroupExpenses(groupId: string, callback: (expense: Expense) =&gt; void) {&#10;    return supabase&#10;      .channel(`group-${groupId}`)&#10;      .on(&#10;        'postgres_changes',&#10;        {&#10;          event: '*',&#10;          schema: 'public',&#10;          table: 'expenses',&#10;          filter: `group_id=eq.${groupId}`&#10;        },&#10;        (payload) =&gt; {&#10;          if (payload.eventType === 'INSERT') {&#10;            callback(payload.new as Expense)&#10;          }&#10;        }&#10;      )&#10;      .subscribe()&#10;  }&#10;&#10;  static subscribeToUserGroups(userId: string, callback: (group: Group) =&gt; void) {&#10;    return supabase&#10;      .channel(`user-groups-${userId}`)&#10;      .on(&#10;        'postgres_changes',&#10;        {&#10;          event: '*',&#10;          schema: 'public',&#10;          table: 'groups',&#10;          filter: `user_id=eq.${userId}`&#10;        },&#10;        (payload) =&gt; {&#10;          if (payload.eventType === 'INSERT') {&#10;            callback(payload.new as Group)&#10;          }&#10;        }&#10;      )&#10;      .subscribe()&#10;  }&#10;&#10;  // Members operations (assuming members are stored as JSON in groups table or separate table)&#10;  static async updateGroupMembers(groupId: string, userId: string, members: string[]): Promise&lt;void&gt; {&#10;    const { error } = await supabase&#10;      .from('groups')&#10;      .update({ members })&#10;      .eq('id', groupId)&#10;      .eq('user_id', userId)&#10;&#10;    if (error) throw error&#10;  }&#10;&#10;  // Get user ID from current session&#10;  static async getCurrentUserId(): Promise&lt;string | null&gt; {&#10;    const { data: { user } } = await supabase.auth.getUser()&#10;    return user?.id || null&#10;  }&#10;&#10;  // Exchange rates storage (if needed)&#10;  static async updateExchangeRates(userId: string, rates: Record&lt;string, number&gt;, base: string): Promise&lt;void&gt; {&#10;    const { error } = await supabase&#10;      .from('user_settings')&#10;      .upsert([{&#10;        user_id: userId,&#10;        exchange_rates: rates,&#10;        base_currency: base,&#10;        updated_at: new Date().toISOString()&#10;      }])&#10;    if (error) throw error&#10;    if (error) throw error&#10;    if (error) throw error&#10;    if (error &amp;&amp; error.code !== 'PGRST116') throw error&#10;    return data ? { rates: data.exchange_rates || {}, base: data.base_currency || 'EUR' } : null&#10;    const { data, error } = await supabase&#10;      .from('user_settings')&#10;      .select('exchange_rates, base_currency')&#10;      .eq('user_id', userId)&#10;      .single()&#10;" />
              <option name="updatedContent" value="import { supabase } from '../lib/supabase'&#10;&#10;// Database types for better TypeScript support&#10;export interface Group {&#10;  id: string&#10;  user_id: string&#10;  name: string&#10;  currency: string&#10;  members: string[]&#10;  created_at: string&#10;}&#10;&#10;export interface Expense {&#10;  id: string&#10;  user_id: string&#10;  group_id: string&#10;  amount: number&#10;  payer: string&#10;  for_members: string[]&#10;  note?: string&#10;  date: string&#10;  currency?: string&#10;}&#10;&#10;// Client-side database operations using Supabase&#10;export class SupabaseService {&#10;  // Groups operations&#10;  static async getGroups(userId: string): Promise&lt;Group[]&gt; {&#10;    const { data, error } = await supabase&#10;      .from('groups')&#10;      .select('id, user_id, name, currency, members, created_at')&#10;      .eq('user_id', userId)&#10;      .order('created_at', { ascending: false })&#10;&#10;    if (error) throw error&#10;    return data || []&#10;  }&#10;&#10;  static async createGroup(userId: string, name: string, currency: string = 'EUR', members: string[] = []): Promise&lt;string&gt; {&#10;    const { data, error } = await supabase&#10;      .from('groups')&#10;      .insert([{ user_id: userId, name, currency, members }])&#10;      .select('id')&#10;      .single()&#10;    &#10;    if (error) throw error&#10;    return data.id&#10;  }&#10;&#10;  static async updateGroup(groupId: string, userId: string, updates: { name?: string; currency?: string }): Promise&lt;void&gt; {&#10;    const { error } = await supabase&#10;      .from('groups')&#10;      .update(updates)&#10;      .eq('id', groupId)&#10;      .eq('user_id', userId)&#10;&#10;    if (error) throw error&#10;  }&#10;&#10;  static async deleteGroup(groupId: string, userId: string): Promise&lt;void&gt; {&#10;    const { error } = await supabase&#10;      .from('groups')&#10;      .delete()&#10;      .eq('id', groupId)&#10;      .eq('user_id', userId)&#10;    &#10;    if (error) throw error&#10;  }&#10;&#10;  // Expenses operations&#10;  static async getExpenses(groupId: string): Promise&lt;Expense[]&gt; {&#10;    const { data, error } = await supabase&#10;      .from('expenses')&#10;      .select('*')&#10;      .eq('group_id', groupId)&#10;      .order('date', { ascending: false })&#10;    &#10;    if (error) throw error&#10;    return data || []&#10;  }&#10;&#10;  static async createExpense(expense: Omit&lt;Expense, 'id' | 'date'&gt;): Promise&lt;string&gt; {&#10;    const { data, error } = await supabase&#10;      .from('expenses')&#10;      .insert([{ ...expense, date: new Date().toISOString() }])&#10;      .select('id')&#10;      .single()&#10;    &#10;    if (error) throw error&#10;    return data.id&#10;  }&#10;&#10;  static async deleteExpense(expenseId: string, userId: string): Promise&lt;void&gt; {&#10;    const { error } = await supabase&#10;      .from('expenses')&#10;      .delete()&#10;      .eq('id', expenseId)&#10;      .eq('user_id', userId)&#10;    &#10;    if (error) throw error&#10;  }&#10;&#10;  // Real-time subscriptions&#10;  static subscribeToGroupExpenses(groupId: string, callback: (expense: Expense) =&gt; void) {&#10;    return supabase&#10;      .channel(`group-${groupId}`)&#10;      .on(&#10;        'postgres_changes',&#10;        {&#10;          event: '*',&#10;          schema: 'public',&#10;          table: 'expenses',&#10;          filter: `group_id=eq.${groupId}`&#10;        },&#10;        (payload) =&gt; {&#10;          if (payload.eventType === 'INSERT') {&#10;            callback(payload.new as Expense)&#10;          }&#10;        }&#10;      )&#10;      .subscribe()&#10;  }&#10;&#10;  static subscribeToUserGroups(userId: string, callback: (group: Group) =&gt; void) {&#10;    return supabase&#10;      .channel(`user-groups-${userId}`)&#10;      .on(&#10;        'postgres_changes',&#10;        {&#10;          event: '*',&#10;          schema: 'public',&#10;          table: 'groups',&#10;          filter: `user_id=eq.${userId}`&#10;        },&#10;        (payload) =&gt; {&#10;          if (payload.eventType === 'INSERT') {&#10;            callback(payload.new as Group)&#10;          }&#10;        }&#10;      )&#10;      .subscribe()&#10;  }&#10;&#10;  // Members operations (assuming members are stored as JSON in groups table or separate table)&#10;  static async updateGroupMembers(groupId: string, userId: string, members: string[]): Promise&lt;void&gt; {&#10;    const { error } = await supabase&#10;      .from('groups')&#10;      .update({ members })&#10;      .eq('id', groupId)&#10;      .eq('user_id', userId)&#10;&#10;    if (error) throw error&#10;  }&#10;&#10;  // Get user ID from current session&#10;  static async getCurrentUserId(): Promise&lt;string | null&gt; {&#10;    const { data: { user } } = await supabase.auth.getUser()&#10;    return user?.id || null&#10;  }&#10;&#10;  // Exchange rates storage (if needed)&#10;  static async updateExchangeRates(userId: string, rates: Record&lt;string, number&gt;, base: string): Promise&lt;void&gt; {&#10;    try {&#10;      const { error } = await supabase&#10;        .from('user_settings')&#10;        .upsert([{&#10;          user_id: userId,&#10;          exchange_rates: rates,&#10;          base_currency: base,&#10;          updated_at: new Date().toISOString()&#10;        }])&#10;&#10;      if (error) {&#10;        console.error('Error updating exchange rates:', error)&#10;        throw error&#10;      }&#10;    } catch (error) {&#10;      console.error('Failed to update exchange rates:', error)&#10;      // Don't throw error to prevent app crashes&#10;    }&#10;  }&#10;&#10;  static async getExchangeRates(userId: string): Promise&lt;{ rates: Record&lt;string, number&gt;; base: string } | null&gt; {&#10;    try {&#10;      const { data, error } = await supabase&#10;        .from('user_settings')&#10;        .select('exchange_rates, base_currency')&#10;        .eq('user_id', userId)&#10;        .maybeSingle() // Use maybeSingle instead of single to handle missing records&#10;&#10;      if (error) {&#10;        console.error('Error fetching exchange rates:', error)&#10;        return null&#10;      }&#10;      &#10;      return data ? { &#10;        rates: data.exchange_rates || {}, &#10;        base: data.base_currency || 'EUR' &#10;      } : null&#10;    } catch (error) {&#10;      console.error('Failed to fetch exchange rates:', error)&#10;      return null&#10;    }&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/router.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/router.ts" />
              <option name="originalContent" value="import { createRouter, createWebHistory } from 'vue-router'&#10;import GroupSelect from './components/GroupSelect.vue'&#10;import ExpenseList from './components/ExpenseList.vue'&#10;import SignIn from './components/SignIn.vue'&#10;&#10;const routes = [&#10;  { path: '/signin', component: SignIn },&#10;  { path: '/', redirect: '/groups' },&#10;  { path: '/groups', component: GroupSelect, meta: { requiresAuth: true } },&#10;  { path: '/groups/:id', component: ExpenseList, meta: { requiresAuth: true } },&#10;]&#10;&#10;const router = createRouter({ history: createWebHistory(), routes })&#10;&#10;router.beforeEach(async (to, from, next) =&gt; {&#10;  const clerk = (window as any).Clerk&#10;  if (!clerk) {&#10;  // Wait for Clerk to be fully loaded&#10;  if (!clerk) {&#10;    return next()&#10;  }&#10;  if (to.meta.requiresAuth) {&#10;  // Check if route requires authentication&#10;  if (to.meta.requiresAuth) {&#10;    // Wait for user state to be determined&#10;    if (clerk.loaded &amp;&amp; !clerk.user) {&#10;" />
              <option name="updatedContent" value="import { createRouter, createWebHistory } from 'vue-router'&#10;import GroupSelect from './components/GroupSelect.vue'&#10;import ExpenseList from './components/ExpenseList.vue'&#10;import SignIn from './components/SignIn.vue'&#10;&#10;const routes = [&#10;  { path: '/signin', component: SignIn },&#10;  { path: '/', redirect: '/groups' },&#10;  { path: '/groups', component: GroupSelect, meta: { requiresAuth: true } },&#10;  { path: '/groups/:id', component: ExpenseList, meta: { requiresAuth: true } },&#10;]&#10;&#10;const router = createRouter({ history: createWebHistory(), routes })&#10;&#10;router.beforeEach(async (to, from, next) =&gt; {&#10;  // Check if route requires authentication&#10;  if (to.meta.requiresAuth) {&#10;    const clerk = (window as any).Clerk&#10;&#10;    // If Clerk is not available, allow navigation (fallback)&#10;    if (!clerk) {&#10;      return next()&#10;    }&#10;&#10;    // Wait for Clerk to be fully loaded&#10;    if (!clerk.loaded) {&#10;      await new Promise(resolve =&gt; {&#10;        const checkLoaded = () =&gt; {&#10;          if (clerk.loaded) {&#10;            resolve(true)&#10;          } else {&#10;            setTimeout(checkLoaded, 100)&#10;          }&#10;        }&#10;        checkLoaded()&#10;      })&#10;    }&#10;&#10;    // Check if user is authenticated&#10;    if (!clerk.user) {&#10;      return next('/signin')&#10;    }&#10;  }&#10;&#10;  next()&#10;})&#10;&#10;export default router" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/vercel.json">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/vercel.json" />
              <option name="originalContent" value="{&#10;  &quot;functions&quot;: {&#10;    &quot;api/**/*.ts&quot;: {&#10;      &quot;runtime&quot;: &quot;@vercel/node@3.0.7&quot;&#10;    }&#10;  },&#10;  &quot;build&quot;: {&#10;    &quot;env&quot;: {&#10;      &quot;VITE_SUPABASE_URL&quot;: &quot;https://fedgovdtnecuwywkveou.supabase.co&quot;,&#10;      &quot;VITE_SUPABASE_ANON_KEY&quot;: &quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZlZGdvdmR0bmVjdXd5d2t2ZW91Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQ2NjU5NjMsImV4cCI6MjA3MDI0MTk2M30.0VJu25tU_EoyZxuZnEfgwW05jX8lJZtWawlV3cI_5eE&quot;&#10;    }&#10;  },&#10;  &quot;buildCommand&quot;: &quot;pnpm run build&quot;,&#10;  &quot;installCommand&quot;: &quot;pnpm install&quot;,&#10;  &quot;outputDirectory&quot;: &quot;dist&quot;,&#10;  &quot;nodeVersion&quot;: &quot;18.x&quot;&#10;  &quot;nodeVersion&quot;: &quot;18.x&quot;&#10;  &quot;nodeVersion&quot;: &quot;18.x&quot;&#10;  &quot;nodeVersion&quot;: &quot;18.x&quot;&#10;  &quot;nodeVersion&quot;: &quot;18.x&quot;&#10;  &quot;nodeVersion&quot;: &quot;18.x&quot;&#10;  &quot;nodeVersion&quot;: &quot;18.x&quot;&#10;  &quot;nodeVersion&quot;: &quot;18.x&quot;&#10;  &quot;nodeVersion&quot;: &quot;18.x&quot;&#10;  &quot;nodeVersion&quot;: &quot;18.x&quot;&#10;  &quot;nodeVersion&quot;: &quot;18.x&quot;&#10;  &quot;nodeVersion&quot;: &quot;18.x&quot;&#10;  &quot;nodeVersion&quot;: &quot;18.x&quot;&#10;  &quot;nodeVersion&quot;: &quot;18.x&quot;&#10;  &quot;nodeVersion&quot;: &quot;18.x&quot;&#10;  &quot;nodeVersion&quot;: &quot;18.x&quot;&#10;}&#10;" />
              <option name="updatedContent" value="{&#10;  &quot;functions&quot;: {&#10;    &quot;api/**/*.ts&quot;: {&#10;      &quot;runtime&quot;: &quot;@vercel/node@3.0.7&quot;&#10;    }&#10;  },&#10;  &quot;build&quot;: {&#10;    &quot;env&quot;: {&#10;      &quot;VITE_SUPABASE_URL&quot;: &quot;https://fedgovdtnecuwywkveou.supabase.co&quot;,&#10;      &quot;VITE_SUPABASE_ANON_KEY&quot;: &quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZlZGdvdmR0bmVjdXd5d2t2ZW91Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQ2NjU5NjMsImV4cCI6MjA3MDI0MTk2M30.0VJu25tU_EoyZxuZnEfgwW05jX8lJZtWawlV3cI_5eE&quot;&#10;    }&#10;  },&#10;  &quot;buildCommand&quot;: &quot;pnpm run build&quot;,&#10;  &quot;installCommand&quot;: &quot;pnpm install&quot;,&#10;  &quot;outputDirectory&quot;: &quot;dist&quot;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/vite.config.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/vite.config.ts" />
              <option name="originalContent" value="import { defineConfig } from 'vite'&#10;import vue from '@vitejs/plugin-vue'&#10;&#10;export default defineConfig({&#10;  plugins: [vue()],&#10;  server: {&#10;    port: 5173,&#10;    historyApiFallback: true,&#10;    historyApiFallback: true,&#10;    proxy: {&#10;      '/api': {&#10;        target: 'http://localhost:3000',&#10;        changeOrigin: true,&#10;        rewrite: (path) =&gt; path.replace(/^\/api/, '/api')&#10;      }&#10;    }&#10;  },&#10;  define: {&#10;    // Expose environment variables to the client&#10;    __SUPABASE_URL__: JSON.stringify(process.env.VITE_SUPABASE_URL),&#10;    __SUPABASE_ANON_KEY__: JSON.stringify(process.env.VITE_SUPABASE_ANON_KEY),&#10;  }&#10;})&#10;" />
              <option name="updatedContent" value="import { defineConfig } from 'vite'&#10;import vue from '@vitejs/plugin-vue'&#10;&#10;export default defineConfig({&#10;  plugins: [vue()],&#10;  server: {&#10;    port: 5173,&#10;    proxy: {&#10;      '/api': {&#10;        target: 'http://localhost:3000',&#10;        changeOrigin: true,&#10;        rewrite: (path) =&gt; path.replace(/^\/api/, '/api')&#10;      }&#10;    }&#10;  },&#10;  define: {&#10;    // Expose environment variables to the client&#10;    __SUPABASE_URL__: JSON.stringify(process.env.VITE_SUPABASE_URL),&#10;    __SUPABASE_ANON_KEY__: JSON.stringify(process.env.VITE_SUPABASE_ANON_KEY),&#10;  }&#10;})" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>
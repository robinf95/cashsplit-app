<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.gitignore">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.gitignore" />
              <option name="originalContent" value="/node_modules&#10;.vercel&#10;" />
              <option name="updatedContent" value="/node_modules&#10;.vercel&#10;&#10;# Environment variables&#10;.env&#10;.env.local&#10;.env.development.local&#10;.env.test.local&#10;.env.production.local&#10;&#10;# Build outputs&#10;dist/&#10;&#10;# IDE&#10;.vscode/&#10;.idea/&#10;&#10;# OS&#10;.DS_Store&#10;Thumbs.db" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/api/_db.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/api/_db.ts" />
              <option name="originalContent" value="import { createPool } from '@vercel/postgres'&#10;export const pool=createPool()&#10;" />
              <option name="updatedContent" value="import { createPool } from '@vercel/postgres'&#10;import { createClient } from '@supabase/supabase-js'&#10;&#10;// Vercel Postgres pool for server-side operations&#10;export const pool = createPool()&#10;&#10;// Supabase client for server-side operations with service role&#10;const supabaseUrl = process.env.SUPABASE_URL || process.env.NEXT_PUBLIC_SUPABASE_URL!&#10;const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY!&#10;&#10;export const supabaseAdmin = createClient(supabaseUrl, supabaseServiceKey, {&#10;  auth: {&#10;    autoRefreshToken: false,&#10;    persistSession: false&#10;  }&#10;})&#10;&#10;// Regular Supabase client for server-side operations&#10;const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!&#10;export const supabase = createClient(supabaseUrl, supabaseAnonKey)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/db/schema.sql">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/db/schema.sql" />
              <option name="originalContent" value="create extension if not exists pgcrypto;&#10;create table if not exists groups (&#10;  id uuid primary key,&#10;  user_id text not null,&#10;  name text not null,&#10;  currency text not null default 'EUR',&#10;  created_at timestamptz not null default now()&#10;);&#10;create table if not exists expenses (&#10;  id uuid primary key,&#10;  user_id text not null,&#10;  group_id uuid not null references groups(id) on delete cascade,&#10;  amount numeric(12,2) not null check (amount &gt;= 0),&#10;  payer text not null,&#10;  for_members text[] not null,&#10;  note text,&#10;  date timestamptz not null default now(),&#10;  currency text&#10;);" />
              <option name="updatedContent" value="create extension if not exists pgcrypto;&#10;create table if not exists groups (&#10;  id uuid primary key default gen_random_uuid(),&#10;  user_id text not null,&#10;  name text not null,&#10;  currency text not null default 'EUR',&#10;  members text[] not null default '{}',&#10;  created_at timestamptz not null default now()&#10;);&#10;create table if not exists expenses (&#10;  id uuid primary key default gen_random_uuid(),&#10;  user_id text not null,&#10;  group_id uuid not null references groups(id) on delete cascade,&#10;  amount numeric(12,2) not null check (amount &gt;= 0),&#10;  payer text not null,&#10;  for_members text[] not null,&#10;  note text,&#10;  date timestamptz not null default now(),&#10;  currency text&#10;);&#10;create table if not exists user_settings (&#10;  user_id text primary key,&#10;  exchange_rates jsonb default '{}',&#10;  base_currency text default 'EUR',&#10;  updated_at timestamptz not null default now()&#10;);" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/App.vue">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/App.vue" />
              <option name="originalContent" value="&lt;script setup lang=&quot;ts&quot;&gt;&#10;import { onMounted, ref, watch } from 'vue'&#10;import { useExpenseStore } from './stores/expenses'&#10;&#10;const clerk: any = (window as any).Clerk&#10;const user = ref&lt;any&gt;(null)&#10;const expenseStore = useExpenseStore()&#10;&#10;onMounted(async () =&gt; {&#10;  try {&#10;    user.value = await clerk.user?.reload?.() || clerk.user&#10;&#10;    // Initialize the store after mounting&#10;    await expenseStore.initialize()&#10;  } catch {}&#10;})&#10;&#10;// Watch for user changes and reinitialize store&#10;watch(user, async (newUser) =&gt; {&#10;  if (newUser) {&#10;    await expenseStore.initialize()&#10;  } else {&#10;    // Clear store when user signs out&#10;    expenseStore.$reset()&#10;  }&#10;}, { immediate: false })&#10;&#10;const signOut = async () =&gt; {&#10;  await clerk.signOut()&#10;  location.href = '/signin'&#10;}&#10;&#10;const openSignIn = async () =&gt; {&#10;  await clerk.openSignIn()&#10;}&#10;&lt;/script&gt;&#10;&#10;&lt;template&gt;&#10;  &lt;main class=&quot;min-h-screen max-w-xl mx-auto p-4 sm:p-6&quot;&gt;&#10;    &lt;header class=&quot;flex items-center justify-between mb-4&quot;&gt;&#10;      &lt;h1 class=&quot;text-2xl font-semibold tracking-tight&quot;&gt; CashSplit&lt;/h1&gt;&#10;      &lt;div class=&quot;flex items-center gap-3&quot;&gt;&#10;        &lt;span v-if=&quot;user&quot; class=&quot;text-xs text-gray-600 dark:text-gray-300&quot;&gt;Hi, {{ user.firstName || user.username }}&lt;/span&gt;&#10;        &lt;button v-if=&quot;user&quot; class=&quot;text-sm underline&quot; @click=&quot;signOut&quot;&gt;Logout&lt;/button&gt;&#10;        &lt;button v-else class=&quot;text-sm underline&quot; @click=&quot;openSignIn&quot;&gt;Login&lt;/button&gt;&#10;      &lt;/div&gt;&#10;    &lt;/header&gt;&#10;    &lt;router-view /&gt;&#10;    &lt;footer class=&quot;mt-8 text-center text-xs text-gray-500 dark:text-gray-400&quot;&gt;&#10;      Built with Vue &amp; Tailwind • Vercel Functions + Postgres • PWA&#10;    &lt;/footer&gt;&#10;  &lt;/main&gt;&#10;&lt;/template&gt;" />
              <option name="updatedContent" value="&lt;script setup lang=&quot;ts&quot;&gt;&#10;import { onMounted, ref, watch } from 'vue'&#10;import { useExpenseStore } from './stores/expenses'&#10;&#10;const clerk: any = (window as any).Clerk&#10;const user = ref&lt;any&gt;(null)&#10;const expenseStore = useExpenseStore()&#10;let isInitialized = false&#10;&#10;onMounted(async () =&gt; { &#10;  try { &#10;    user.value = await clerk.user?.reload?.() || clerk.user&#10;    &#10;    // Initialize the store only once after mounting&#10;    if (!isInitialized) {&#10;      await expenseStore.initialize()&#10;      isInitialized = true&#10;    }&#10;  } catch (error) {&#10;    console.error('Error during app initialization:', error)&#10;    // Initialize store even on error to provide demo data&#10;    if (!isInitialized) {&#10;      await expenseStore.initialize()&#10;      isInitialized = true&#10;    }&#10;  }&#10;})&#10;&#10;// Watch for user changes and reinitialize store only when needed&#10;watch(user, async (newUser, oldUser) =&gt; {&#10;  // Only reinitialize if user actually changed (not just initial load)&#10;  if (oldUser !== undefined &amp;&amp; newUser?.id !== oldUser?.id) {&#10;    if (newUser) {&#10;      await expenseStore.initialize()&#10;    } else {&#10;      // Clear store when user signs out&#10;      expenseStore.$reset()&#10;      isInitialized = false&#10;    }&#10;  }&#10;}, { immediate: false })&#10;&#10;const signOut = async () =&gt; { &#10;  await clerk.signOut()&#10;  location.href = '/signin' &#10;}&#10;&#10;const openSignIn = async () =&gt; { &#10;  await clerk.openSignIn() &#10;}&#10;&lt;/script&gt;&#10;&#10;&lt;template&gt;&#10;  &lt;main class=&quot;min-h-screen max-w-xl mx-auto p-4 sm:p-6&quot;&gt;&#10;    &lt;header class=&quot;flex items-center justify-between mb-4&quot;&gt;&#10;      &lt;h1 class=&quot;text-2xl font-semibold tracking-tight&quot;&gt; CashSplit&lt;/h1&gt;&#10;      &lt;div class=&quot;flex items-center gap-3&quot;&gt;&#10;        &lt;span v-if=&quot;user&quot; class=&quot;text-xs text-gray-600 dark:text-gray-300&quot;&gt;Hi, {{ user.firstName || user.username }}&lt;/span&gt;&#10;        &lt;button v-if=&quot;user&quot; class=&quot;text-sm underline&quot; @click=&quot;signOut&quot;&gt;Logout&lt;/button&gt;&#10;        &lt;button v-else class=&quot;text-sm underline&quot; @click=&quot;openSignIn&quot;&gt;Login&lt;/button&gt;&#10;      &lt;/div&gt;&#10;    &lt;/header&gt;&#10;    &lt;router-view /&gt;&#10;    &lt;footer class=&quot;mt-8 text-center text-xs text-gray-500 dark:text-gray-400&quot;&gt;&#10;      Built with Vue &amp; Tailwind • Vercel Functions + Postgres • PWA&#10;    &lt;/footer&gt;&#10;  &lt;/main&gt;&#10;&lt;/template&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/GroupSelect.vue">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/GroupSelect.vue" />
              <option name="originalContent" value="&lt;script setup lang=&quot;ts&quot;&gt;&#10;import { ref } from 'vue'&#10;import { useRouter } from 'vue-router'&#10;import { useExpenseStore, type Currency } from '../stores/expenses'&#10;&#10;const s = useExpenseStore()&#10;const router = useRouter()&#10;const groupName = ref('')&#10;const memberNames = ref('Alice,Bob')&#10;const currency = ref&lt;Currency&gt;('EUR')&#10;&#10;async function create() {&#10;  const members = memberNames.value.split(',').map(x=&gt;x.trim()).filter(Boolean)&#10;  if (!groupName.value || members.length &lt; 1) return&#10;&#10;  try {&#10;    await s.addGroup(groupName.value, members, currency.value)&#10;    // Now get the ID from the last group that was actually added&#10;    const newGroup = s.groups[s.groups.length-1]&#10;    if (newGroup?.id) {&#10;      router.push(`/groups/${newGroup.id}`)&#10;    }&#10;  } catch (error) {&#10;    console.error('Failed to create group:', error)&#10;    // Show error to user or handle gracefully&#10;  }&#10;}&#10;&#10;async function deleteGroup(groupId: string, groupName: string) {&#10;  if (confirm(`Möchten Sie die Gruppe &quot;${groupName}&quot; wirklich löschen? Alle zugehörigen Ausgaben werden ebenfalls gelöscht.`)) {&#10;    try {&#10;      await s.deleteGroup(groupId)&#10;      // If we're currently viewing this group, redirect to home&#10;      if (router.currentRoute.value.params.id === groupId) {&#10;        router.push('/')&#10;      }&#10;    } catch (error) {&#10;      console.error('Failed to delete group:', error)&#10;      alert('Fehler beim Löschen der Gruppe')&#10;    }&#10;  }&#10;}&#10;&lt;/script&gt;&#10;&#10;&lt;template&gt;&#10;  &lt;section class=&quot;grid gap-4&quot;&gt;&#10;    &lt;div class=&quot;card&quot;&gt;&#10;      &lt;h2 class=&quot;text-lg font-semibold mb-2&quot;&gt;Gruppen&lt;/h2&gt;&#10;      &lt;ul class=&quot;divide-y divide-gray-200 dark:divide-gray-700&quot;&gt;&#10;        &lt;li v-for=&quot;g in s.groups&quot; :key=&quot;g.id&quot; class=&quot;py-2 flex items-center justify-between&quot;&gt;&#10;          &lt;div&gt;&#10;            &lt;div class=&quot;font-medium&quot;&gt;{{ g.name }}&lt;/div&gt;&#10;            &lt;div class=&quot;text-xs text-gray-500&quot;&gt;{{ g.members.join(', ') }} · {{ g.currency }}&lt;/div&gt;&#10;          &lt;/div&gt;&#10;          &lt;div class=&quot;flex gap-2&quot;&gt;&#10;            &lt;router-link :to=&quot;`/groups/${g.id}`&quot; class=&quot;btn-primary&quot;&gt;Öffnen&lt;/router-link&gt;&#10;            &lt;button&#10;              @click=&quot;deleteGroup(g.id, g.name)&quot;&#10;              class=&quot;btn-secondary text-red-600 hover:bg-red-50 hover:text-red-700 dark:hover:bg-red-900/20&quot;&#10;              title=&quot;Gruppe löschen&quot;&#10;            &gt;&#10;              Löschen&#10;            &lt;/button&gt;&#10;          &lt;/div&gt;&#10;        &lt;/li&gt;&#10;      &lt;/ul&gt;&#10;    &lt;/div&gt;&#10;&#10;    &lt;div class=&quot;card&quot;&gt;&#10;      &lt;h2 class=&quot;text-lg font-semibold mb-2&quot;&gt;Neue Gruppe&lt;/h2&gt;&#10;      &lt;div class=&quot;grid gap-2&quot;&gt;&#10;        &lt;label class=&quot;label&quot;&gt;Name&lt;/label&gt;&#10;        &lt;input v-model=&quot;groupName&quot; class=&quot;input&quot; placeholder=&quot;z. B. Kreta 2025&quot; /&gt;&#10;        &lt;label class=&quot;label&quot;&gt;Mitglieder (Kommagetrennt)&lt;/label&gt;&#10;        &lt;input v-model=&quot;memberNames&quot; class=&quot;input&quot; /&gt;&#10;        &lt;label class=&quot;label&quot;&gt;Währung&lt;/label&gt;&#10;        &lt;select v-model=&quot;currency&quot; class=&quot;input&quot;&gt;&#10;          &lt;option&gt;EUR&lt;/option&gt;&lt;option&gt;USD&lt;/option&gt;&lt;option&gt;CHF&lt;/option&gt;&lt;option&gt;GBP&lt;/option&gt;&#10;        &lt;/select&gt;&#10;        &lt;button @click=&quot;create&quot; class=&quot;btn-primary mt-2&quot;&gt;Erstellen&lt;/button&gt;&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  &lt;/section&gt;&#10;&lt;/template&gt;" />
              <option name="updatedContent" value="&lt;script setup lang=&quot;ts&quot;&gt;&#10;import { ref } from 'vue'&#10;import { useRouter } from 'vue-router'&#10;import { useExpenseStore, type Currency } from '../stores/expenses'&#10;&#10;const s = useExpenseStore()&#10;const router = useRouter()&#10;const groupName = ref('')&#10;const memberNames = ref('Alice,Bob')&#10;const currency = ref&lt;Currency&gt;('EUR')&#10;&#10;async function create() {&#10;  const members = memberNames.value.split(',').map(x=&gt;x.trim()).filter(Boolean)&#10;  if (!groupName.value || members.length &lt; 1) return&#10;&#10;  try {&#10;    await s.addGroup(groupName.value, members, currency.value)&#10;    // Now get the ID from the last group that was actually added&#10;    const newGroup = s.groups[s.groups.length-1]&#10;    if (newGroup?.id) {&#10;      router.push(`/groups/${newGroup.id}`)&#10;    }&#10;  } catch (error) {&#10;    console.error('Failed to create group:', error)&#10;    // Show error to user or handle gracefully&#10;  }&#10;}&#10;&#10;async function deleteGroup(groupId: string, groupName: string) {&#10;  if (confirm(`Möchten Sie die Gruppe &quot;${groupName}&quot; wirklich löschen? Alle zugehörigen Ausgaben werden ebenfalls gelöscht.`)) {&#10;    try {&#10;      await s.deleteGroup(groupId)&#10;      // If we're currently viewing this group, redirect to home&#10;      if (router.currentRoute.value.params.id === groupId) {&#10;        router.push('/')&#10;      }&#10;    } catch (error) {&#10;      console.error('Failed to delete group:', error)&#10;      alert('Fehler beim Löschen der Gruppe')&#10;    }&#10;  }&#10;}&#10;&lt;/script&gt;&#10;&#10;&lt;template&gt;&#10;  &lt;section class=&quot;grid gap-4&quot;&gt;&#10;    &lt;div class=&quot;card&quot;&gt;&#10;      &lt;h2 class=&quot;text-lg font-semibold mb-2&quot;&gt;Gruppen&lt;/h2&gt;&#10;      &lt;ul class=&quot;divide-y divide-gray-200 dark:divide-gray-700&quot;&gt;&#10;        &lt;li v-for=&quot;g in s.groups&quot; :key=&quot;g.id&quot; class=&quot;py-2 flex items-center justify-between&quot;&gt;&#10;          &lt;div&gt;&#10;            &lt;div class=&quot;font-medium&quot;&gt;{{ g.name }}&lt;/div&gt;&#10;            &lt;div class=&quot;text-xs text-gray-500&quot;&gt;{{ g.members.join(', ') }} · {{ g.currency }}&lt;/div&gt;&#10;          &lt;/div&gt;&#10;          &lt;div class=&quot;flex gap-2&quot;&gt;&#10;            &lt;router-link :to=&quot;`/groups/${g.id}`&quot; class=&quot;btn-primary&quot;&gt;Öffnen&lt;/router-link&gt;&#10;            &lt;button &#10;              @click=&quot;deleteGroup(g.id, g.name)&quot; &#10;              class=&quot;btn-secondary text-red-600 hover:bg-red-50 hover:text-red-700 dark:hover:bg-red-900/20 p-2&quot;&#10;              title=&quot;Gruppe löschen&quot;&#10;            &gt;&#10;              &lt;svg width=&quot;16&quot; height=&quot;16&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; stroke=&quot;currentColor&quot; stroke-width=&quot;2&quot; stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot;&gt;&#10;                &lt;polyline points=&quot;3,6 5,6 21,6&quot;&gt;&lt;/polyline&gt;&#10;                &lt;path d=&quot;m19,6v14a2,2 0 0,1 -2,2H7a2,2 0 0,1 -2,-2V6m3,0V4a2,2 0 0,1 2,-2h4a2,2 0 0,1 2,2v2&quot;&gt;&lt;/path&gt;&#10;                &lt;line x1=&quot;10&quot; y1=&quot;11&quot; x2=&quot;10&quot; y2=&quot;17&quot;&gt;&lt;/line&gt;&#10;                &lt;line x1=&quot;14&quot; y1=&quot;11&quot; x2=&quot;14&quot; y2=&quot;17&quot;&gt;&lt;/line&gt;&#10;              &lt;/svg&gt;&#10;            &lt;/button&gt;&#10;          &lt;/div&gt;&#10;        &lt;/li&gt;&#10;      &lt;/ul&gt;&#10;    &lt;/div&gt;&#10;&#10;    &lt;div class=&quot;card&quot;&gt;&#10;      &lt;h2 class=&quot;text-lg font-semibold mb-2&quot;&gt;Neue Gruppe&lt;/h2&gt;&#10;      &lt;div class=&quot;grid gap-2&quot;&gt;&#10;        &lt;label class=&quot;label&quot;&gt;Name&lt;/label&gt;&#10;        &lt;input v-model=&quot;groupName&quot; class=&quot;input&quot; placeholder=&quot;z. B. Kreta 2025&quot; /&gt;&#10;        &lt;label class=&quot;label&quot;&gt;Mitglieder (Kommagetrennt)&lt;/label&gt;&#10;        &lt;input v-model=&quot;memberNames&quot; class=&quot;input&quot; /&gt;&#10;        &lt;label class=&quot;label&quot;&gt;Währung&lt;/label&gt;&#10;        &lt;select v-model=&quot;currency&quot; class=&quot;input&quot;&gt;&#10;          &lt;option&gt;EUR&lt;/option&gt;&lt;option&gt;USD&lt;/option&gt;&lt;option&gt;CHF&lt;/option&gt;&lt;option&gt;GBP&lt;/option&gt;&#10;        &lt;/select&gt;&#10;        &lt;button @click=&quot;create&quot; class=&quot;btn-primary mt-2&quot;&gt;Erstellen&lt;/button&gt;&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  &lt;/section&gt;&#10;&lt;/template&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/lib/supabase-service.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/lib/supabase-service.ts" />
              <option name="originalContent" value="import { supabase } from '../lib/supabase'&#10;&#10;// Database types for better TypeScript support&#10;export interface Group {&#10;  id: string&#10;  user_id: string&#10;  name: string&#10;  currency: string&#10;  members: string[]&#10;  created_at: string&#10;}&#10;&#10;export interface Expense {&#10;  id: string&#10;  user_id: string&#10;  group_id: string&#10;  amount: number&#10;  payer: string&#10;  for_members: string[]&#10;  note?: string&#10;  date: string&#10;  currency?: string&#10;}&#10;&#10;// Client-side database operations using Supabase&#10;export class SupabaseService {&#10;  // Groups operations&#10;  static async getGroups(userId: string): Promise&lt;Group[]&gt; {&#10;    const { data, error } = await supabase&#10;      .from('groups')&#10;      .select('id, user_id, name, currency, members, created_at')&#10;      .eq('user_id', userId)&#10;      .order('created_at', { ascending: false })&#10;&#10;    if (error) throw error&#10;    return data || []&#10;  }&#10;&#10;  static async createGroup(userId: string, name: string, currency: string = 'EUR', members: string[] = []): Promise&lt;string&gt; {&#10;    const { data, error } = await supabase&#10;      .from('groups')&#10;      .insert([{ user_id: userId, name, currency, members }])&#10;      .select('id')&#10;      .single()&#10;    &#10;    if (error) throw error&#10;    return data.id&#10;  }&#10;&#10;  static async updateGroup(groupId: string, userId: string, updates: { name?: string; currency?: string }): Promise&lt;void&gt; {&#10;    const { error } = await supabase&#10;      .from('groups')&#10;      .update(updates)&#10;      .eq('id', groupId)&#10;      .eq('user_id', userId)&#10;&#10;    if (error) throw error&#10;  }&#10;&#10;  static async deleteGroup(groupId: string, userId: string): Promise&lt;void&gt; {&#10;    const { error } = await supabase&#10;      .from('groups')&#10;      .delete()&#10;      .eq('id', groupId)&#10;      .eq('user_id', userId)&#10;    &#10;    if (error) throw error&#10;  }&#10;&#10;  // Expenses operations&#10;  static async getExpenses(groupId: string): Promise&lt;Expense[]&gt; {&#10;    const { data, error } = await supabase&#10;      .from('expenses')&#10;      .select('*')&#10;      .eq('group_id', groupId)&#10;      .order('date', { ascending: false })&#10;    &#10;    if (error) throw error&#10;    return data || []&#10;  }&#10;&#10;  static async createExpense(expense: Omit&lt;Expense, 'id' | 'date'&gt;): Promise&lt;string&gt; {&#10;    const { data, error } = await supabase&#10;      .from('expenses')&#10;      .insert([{ ...expense, date: new Date().toISOString() }])&#10;      .select('id')&#10;      .single()&#10;    &#10;    if (error) throw error&#10;    return data.id&#10;  }&#10;&#10;  static async deleteExpense(expenseId: string, userId: string): Promise&lt;void&gt; {&#10;    const { error } = await supabase&#10;      .from('expenses')&#10;      .delete()&#10;      .eq('id', expenseId)&#10;      .eq('user_id', userId)&#10;    &#10;    if (error) throw error&#10;  }&#10;&#10;  // Real-time subscriptions&#10;  static subscribeToGroupExpenses(groupId: string, callback: (expense: Expense) =&gt; void) {&#10;    return supabase&#10;      .channel(`group-${groupId}`)&#10;      .on(&#10;        'postgres_changes',&#10;        {&#10;          event: '*',&#10;          schema: 'public',&#10;          table: 'expenses',&#10;          filter: `group_id=eq.${groupId}`&#10;        },&#10;        (payload) =&gt; {&#10;          if (payload.eventType === 'INSERT') {&#10;            callback(payload.new as Expense)&#10;          }&#10;        }&#10;      )&#10;      .subscribe()&#10;  }&#10;&#10;  static subscribeToUserGroups(userId: string, callback: (group: Group) =&gt; void) {&#10;    return supabase&#10;      .channel(`user-groups-${userId}`)&#10;      .on(&#10;        'postgres_changes',&#10;        {&#10;          event: '*',&#10;          schema: 'public',&#10;          table: 'groups',&#10;          filter: `user_id=eq.${userId}`&#10;        },&#10;        (payload) =&gt; {&#10;          if (payload.eventType === 'INSERT') {&#10;            callback(payload.new as Group)&#10;          }&#10;        }&#10;      )&#10;      .subscribe()&#10;  }&#10;&#10;  // Members operations (assuming members are stored as JSON in groups table or separate table)&#10;  static async updateGroupMembers(groupId: string, userId: string, members: string[]): Promise&lt;void&gt; {&#10;    const { error } = await supabase&#10;      .from('groups')&#10;      .update({ members })&#10;      .eq('id', groupId)&#10;      .eq('user_id', userId)&#10;&#10;    if (error) throw error&#10;  }&#10;&#10;  // Get user ID from current session&#10;  static async getCurrentUserId(): Promise&lt;string | null&gt; {&#10;    const { data: { user } } = await supabase.auth.getUser()&#10;    return user?.id || null&#10;  }&#10;&#10;  // Exchange rates storage (if needed)&#10;  static async updateExchangeRates(userId: string, rates: Record&lt;string, number&gt;, base: string): Promise&lt;void&gt; {&#10;    const { error } = await supabase&#10;      .from('user_settings')&#10;      .upsert([{&#10;        user_id: userId,&#10;        exchange_rates: rates,&#10;        base_currency: base,&#10;        updated_at: new Date().toISOString()&#10;      }])&#10;&#10;    if (error) throw error&#10;  }&#10;&#10;  static async getExchangeRates(userId: string): Promise&lt;{ rates: Record&lt;string, number&gt;; base: string } | null&gt; {&#10;    const { data, error } = await supabase&#10;      .from('user_settings')&#10;      .select('exchange_rates, base_currency')&#10;      .eq('user_id', userId)&#10;      .single()&#10;&#10;    if (error &amp;&amp; error.code !== 'PGRST116') throw error&#10;    return data ? { rates: data.exchange_rates || {}, base: data.base_currency || 'EUR' } : null&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="import { supabase } from '../lib/supabase'&#10;&#10;// Database types for better TypeScript support&#10;export interface Group {&#10;  id: string&#10;  user_id: string&#10;  name: string&#10;  currency: string&#10;  members: string[]&#10;  created_at: string&#10;}&#10;&#10;export interface Expense {&#10;  id: string&#10;  user_id: string&#10;  group_id: string&#10;  amount: number&#10;  payer: string&#10;  for_members: string[]&#10;  note?: string&#10;  date: string&#10;  currency?: string&#10;}&#10;&#10;// Client-side database operations using Supabase&#10;export class SupabaseService {&#10;  // Groups operations&#10;  static async getGroups(userId: string): Promise&lt;Group[]&gt; {&#10;    const { data, error } = await supabase&#10;      .from('groups')&#10;      .select('id, user_id, name, currency, members, created_at')&#10;      .eq('user_id', userId)&#10;      .order('created_at', { ascending: false })&#10;&#10;    if (error) throw error&#10;    return data || []&#10;  }&#10;&#10;  static async createGroup(userId: string, name: string, currency: string = 'EUR', members: string[] = []): Promise&lt;string&gt; {&#10;    const { data, error } = await supabase&#10;      .from('groups')&#10;      .insert([{ user_id: userId, name, currency, members }])&#10;      .select('id')&#10;      .single()&#10;    &#10;    if (error) throw error&#10;    return data.id&#10;  }&#10;&#10;  static async updateGroup(groupId: string, userId: string, updates: { name?: string; currency?: string }): Promise&lt;void&gt; {&#10;    const { error } = await supabase&#10;      .from('groups')&#10;      .update(updates)&#10;      .eq('id', groupId)&#10;      .eq('user_id', userId)&#10;&#10;    if (error) throw error&#10;  }&#10;&#10;  static async deleteGroup(groupId: string, userId: string): Promise&lt;void&gt; {&#10;    const { error } = await supabase&#10;      .from('groups')&#10;      .delete()&#10;      .eq('id', groupId)&#10;      .eq('user_id', userId)&#10;    &#10;    if (error) throw error&#10;  }&#10;&#10;  // Expenses operations&#10;  static async getExpenses(groupId: string): Promise&lt;Expense[]&gt; {&#10;    const { data, error } = await supabase&#10;      .from('expenses')&#10;      .select('*')&#10;      .eq('group_id', groupId)&#10;      .order('date', { ascending: false })&#10;    &#10;    if (error) throw error&#10;    return data || []&#10;  }&#10;&#10;  static async createExpense(expense: Omit&lt;Expense, 'id' | 'date'&gt;): Promise&lt;string&gt; {&#10;    const { data, error } = await supabase&#10;      .from('expenses')&#10;      .insert([{ ...expense, date: new Date().toISOString() }])&#10;      .select('id')&#10;      .single()&#10;    &#10;    if (error) throw error&#10;    return data.id&#10;  }&#10;&#10;  static async deleteExpense(expenseId: string, userId: string): Promise&lt;void&gt; {&#10;    const { error } = await supabase&#10;      .from('expenses')&#10;      .delete()&#10;      .eq('id', expenseId)&#10;      .eq('user_id', userId)&#10;    &#10;    if (error) throw error&#10;  }&#10;&#10;  // Real-time subscriptions&#10;  static subscribeToGroupExpenses(groupId: string, callback: (expense: Expense) =&gt; void) {&#10;    return supabase&#10;      .channel(`group-${groupId}`)&#10;      .on(&#10;        'postgres_changes',&#10;        {&#10;          event: '*',&#10;          schema: 'public',&#10;          table: 'expenses',&#10;          filter: `group_id=eq.${groupId}`&#10;        },&#10;        (payload) =&gt; {&#10;          if (payload.eventType === 'INSERT') {&#10;            callback(payload.new as Expense)&#10;          }&#10;        }&#10;      )&#10;      .subscribe()&#10;  }&#10;&#10;  static subscribeToUserGroups(userId: string, callback: (group: Group) =&gt; void) {&#10;    return supabase&#10;      .channel(`user-groups-${userId}`)&#10;      .on(&#10;        'postgres_changes',&#10;        {&#10;          event: '*',&#10;          schema: 'public',&#10;          table: 'groups',&#10;          filter: `user_id=eq.${userId}`&#10;        },&#10;        (payload) =&gt; {&#10;          if (payload.eventType === 'INSERT') {&#10;            callback(payload.new as Group)&#10;          }&#10;        }&#10;      )&#10;      .subscribe()&#10;  }&#10;&#10;  // Members operations (assuming members are stored as JSON in groups table or separate table)&#10;  static async updateGroupMembers(groupId: string, userId: string, members: string[]): Promise&lt;void&gt; {&#10;    const { error } = await supabase&#10;      .from('groups')&#10;      .update({ members })&#10;      .eq('id', groupId)&#10;      .eq('user_id', userId)&#10;&#10;    if (error) throw error&#10;  }&#10;&#10;  // Get user ID from current session&#10;  static async getCurrentUserId(): Promise&lt;string | null&gt; {&#10;    const { data: { user } } = await supabase.auth.getUser()&#10;    return user?.id || null&#10;  }&#10;&#10;  // Exchange rates storage (if needed)&#10;  static async updateExchangeRates(userId: string, rates: Record&lt;string, number&gt;, base: string): Promise&lt;void&gt; {&#10;    try {&#10;      const { error } = await supabase&#10;        .from('user_settings')&#10;        .upsert([{&#10;          user_id: userId,&#10;          exchange_rates: rates,&#10;          base_currency: base,&#10;          updated_at: new Date().toISOString()&#10;        }])&#10;&#10;      if (error) {&#10;        console.error('Error updating exchange rates:', error)&#10;        throw error&#10;      }&#10;    } catch (error) {&#10;      console.error('Failed to update exchange rates:', error)&#10;      // Don't throw error to prevent app crashes&#10;    }&#10;  }&#10;&#10;  static async getExchangeRates(userId: string): Promise&lt;{ rates: Record&lt;string, number&gt;; base: string } | null&gt; {&#10;    try {&#10;      const { data, error } = await supabase&#10;        .from('user_settings')&#10;        .select('exchange_rates, base_currency')&#10;        .eq('user_id', userId)&#10;        .maybeSingle() // Use maybeSingle instead of single to handle missing records&#10;&#10;      if (error) {&#10;        console.error('Error fetching exchange rates:', error)&#10;        return null&#10;      }&#10;      &#10;      return data ? { &#10;        rates: data.exchange_rates || {}, &#10;        base: data.base_currency || 'EUR' &#10;      } : null&#10;    } catch (error) {&#10;      console.error('Failed to fetch exchange rates:', error)&#10;      return null&#10;    }&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/stores/expenses.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/stores/expenses.ts" />
              <option name="originalContent" value="import { defineStore } from 'pinia'&#10;import { SupabaseService } from '../lib/supabase-service'&#10;&#10;export type Currency = 'EUR' | 'USD' | 'CHF' | 'GBP'&#10;export type PersonId = string&#10;&#10;// Updated types to match Supabase schema&#10;export type Group = {&#10;  id: string&#10;  name: string&#10;  members: PersonId[]&#10;  currency: Currency&#10;  user_id?: string&#10;  created_at?: string&#10;}&#10;&#10;export type Expense = {&#10;  id: string&#10;  groupId: string&#10;  payer: PersonId&#10;  for: PersonId[]&#10;  amount: number&#10;  note?: string&#10;  date: string&#10;  currency?: Currency&#10;  user_id?: string&#10;}&#10;&#10;type State = {&#10;  groups: Group[]&#10;  expenses: Expense[]&#10;  fx: Record&lt;string, number&gt;&#10;  base: Currency&#10;  currentUserId: string | null&#10;  loading: boolean&#10;}&#10;&#10;export const useExpenseStore = defineStore('expenses', {&#10;  state: (): State =&gt; ({&#10;    groups: [],&#10;    expenses: [],&#10;    fx: {},&#10;    base: 'EUR',&#10;    currentUserId: null,&#10;    loading: false&#10;  }),&#10;&#10;  getters: {&#10;    groupById: (s) =&gt; (id: string) =&gt; s.groups.find(g =&gt; g.id === id),&#10;    balances: (s) =&gt; (groupId: string) =&gt; {&#10;      const g = s.groups.find(g =&gt; g.id === groupId)&#10;      if (!g) return {}&#10;&#10;      const bal: Record&lt;string, number&gt; = {}&#10;      g.members.forEach(m =&gt; bal[m] = 0)&#10;&#10;      s.expenses.filter(e =&gt; e.groupId === groupId).forEach(e =&gt; {&#10;        const eCur = e.currency || g.currency&#10;        const factor = (eCur === g.currency) ? 1 : (s.fx[`${eCur}-&gt;${g.currency}`] || 1)&#10;        const amt = e.amount * factor&#10;        const share = amt / e.for.length&#10;        bal[e.payer] += amt&#10;        e.for.forEach(m =&gt; bal[m] -= share)&#10;      })&#10;&#10;      Object.keys(bal).forEach(k =&gt; bal[k] = Math.round(bal[k]*100)/100)&#10;      return bal&#10;    },&#10;    settlements() {&#10;      return (groupId: string) =&gt; {&#10;        const b = { ...this.balances(groupId) } as Record&lt;string, number&gt;&#10;        const debtors = Object.entries(b).filter(([,v]) =&gt; v &lt; 0).sort((a,b)=&gt;a[1]-b[1])&#10;        const creditors = Object.entries(b).filter(([,v]) =&gt; v &gt; 0).sort((a,b)=&gt;b[1]-a[1])&#10;        const res: { from:PersonId; to:PersonId; amount:number }[] = []&#10;        let i=0,j=0&#10;&#10;        while (i&lt;debtors.length &amp;&amp; j&lt;creditors.length) {&#10;          const [dId, dAmt] = debtors[i]&#10;          const [cId, cAmt] = creditors[j]&#10;          const pay = Math.min(-dAmt, cAmt)&#10;          if (pay &gt; 0.005) res.push({ from:dId, to:cId, amount:Math.round(pay*100)/100 })&#10;          debtors[i][1] += pay&#10;          creditors[j][1] -= pay&#10;          if (Math.abs(debtors[i][1]) &lt; 1e-9) i++&#10;          if (Math.abs(creditors[j][1]) &lt; 1e-9) j++&#10;        }&#10;        return res&#10;      }&#10;    }&#10;  },&#10;&#10;  actions: {&#10;    async initialize() {&#10;      this.loading = true&#10;      try {&#10;        // Get current user ID (from Clerk or Supabase auth)&#10;        this.currentUserId = await this.getCurrentUserId()&#10;&#10;        if (this.currentUserId) {&#10;          // Load user data from Supabase&#10;          await this.loadUserData()&#10;        } else {&#10;          console.log('No authenticated user found, using empty state')&#10;          // Initialize with demo data if no user is authenticated&#10;          this.groups = [{&#10;            id: 'demo',&#10;            name: 'Beispielgruppe',&#10;            members: ['Alice', 'Bob', 'Clara'],&#10;            currency: 'EUR'&#10;          }]&#10;          this.expenses = []&#10;          this.fx = {}&#10;          this.base = 'EUR'&#10;        }&#10;      } catch (error) {&#10;        console.error('Failed to initialize store:', error)&#10;        // Fallback to demo data on error&#10;        this.groups = [{&#10;          id: 'demo',&#10;          name: 'Beispielgruppe',&#10;          members: ['Alice', 'Bob', 'Clara'],&#10;          currency: 'EUR'&#10;        }]&#10;        this.expenses = []&#10;        this.fx = {}&#10;        this.base = 'EUR'&#10;      } finally {&#10;        this.loading = false&#10;      }&#10;    },&#10;&#10;    async getCurrentUserId(): Promise&lt;string | null&gt; {&#10;      try {&#10;        // First try to get from Clerk&#10;        const clerk = (window as any).Clerk&#10;        if (clerk?.loaded &amp;&amp; clerk?.user?.id) {&#10;          console.log('Found Clerk user:', clerk.user.id)&#10;          return clerk.user.id&#10;        }&#10;&#10;        // Fallback to Supabase auth&#10;        const userId = await SupabaseService.getCurrentUserId()&#10;        if (userId) {&#10;          console.log('Found Supabase user:', userId)&#10;          return userId&#10;        }&#10;&#10;        console.log('No authenticated user found')&#10;        return null&#10;      } catch (error) {&#10;        console.error('Error getting user ID:', error)&#10;        return null&#10;      }&#10;    },&#10;&#10;    async loadUserData() {&#10;      if (!this.currentUserId) return&#10;&#10;      try {&#10;        // Load groups&#10;        const supabaseGroups = await SupabaseService.getGroups(this.currentUserId)&#10;        this.groups = supabaseGroups.map(g =&gt; ({&#10;          id: g.id,&#10;          name: g.name,&#10;          currency: g.currency as Currency,&#10;          members: g.members || [], // Now properly handled from database&#10;          user_id: g.user_id,&#10;          created_at: g.created_at&#10;        }))&#10;&#10;        // Load expenses for all groups&#10;        this.expenses = []&#10;        for (const group of this.groups) {&#10;          const groupExpenses = await SupabaseService.getExpenses(group.id)&#10;          this.expenses.push(...groupExpenses.map(e =&gt; ({&#10;            id: e.id,&#10;            groupId: e.group_id,&#10;            payer: e.payer,&#10;            for: e.for_members,&#10;            amount: e.amount,&#10;            note: e.note,&#10;            date: e.date,&#10;            currency: e.currency as Currency,&#10;            user_id: e.user_id&#10;          })))&#10;        }&#10;&#10;        // Load exchange rates&#10;        const ratesData = await SupabaseService.getExchangeRates(this.currentUserId)&#10;        if (ratesData) {&#10;          this.fx = ratesData.rates&#10;          this.base = ratesData.base as Currency&#10;        }&#10;      } catch (error) {&#10;        console.error('Failed to load user data:', error)&#10;      }&#10;    },&#10;&#10;    async refreshRates(base: Currency, symbols: Currency[]) {&#10;      try {&#10;        console.log(`Fetching exchange rates for ${base} -&gt; ${symbols.join(', ')}`)&#10;&#10;        // Use Hexarate API for each currency pair&#10;        for (const target of symbols) {&#10;          if (target === base) {&#10;            // Same currency, rate is 1&#10;            this.fx[`${base}-&gt;${target}`] = 1&#10;            this.fx[`${target}-&gt;${base}`] = 1&#10;            continue&#10;          }&#10;&#10;          try {&#10;            const apiUrl = `https://hexarate.paikama.co/api/rates/latest/${base}?target=${target}`&#10;            const resp = await fetch(apiUrl)&#10;&#10;            if (resp.ok) {&#10;              const result = await resp.json()&#10;              if (result.status_code === 200 &amp;&amp; result.data?.mid) {&#10;                const rate = result.data.mid&#10;                this.fx[`${base}-&gt;${target}`] = rate&#10;                this.fx[`${target}-&gt;${base}`] = 1 / rate&#10;                console.log(`✓ ${base}/${target}: ${rate}`)&#10;              }&#10;            } else {&#10;              console.warn(`Failed to fetch ${base}/${target} rate: ${resp.status}`)&#10;            }&#10;          } catch (error) {&#10;            console.warn(`Error fetching ${base}/${target} rate:`, error)&#10;          }&#10;        }&#10;&#10;        this.base = base&#10;        console.log('Exchange rates updated successfully from Hexarate API')&#10;&#10;        // Save to Supabase&#10;        if (this.currentUserId) {&#10;          try {&#10;            await SupabaseService.updateExchangeRates(this.currentUserId, this.fx, base)&#10;          } catch (error) {&#10;            console.error('Failed to save exchange rates:', error)&#10;          }&#10;        }&#10;&#10;        // If we didn't get any rates, fall back to static rates&#10;        const hasAnyRates = symbols.some(symbol =&gt; this.fx[`${base}-&gt;${symbol}`] !== undefined)&#10;        if (!hasAnyRates) {&#10;          console.warn('No exchange rates were fetched, using fallback rates')&#10;          this.setFallbackRates(base, symbols)&#10;        }&#10;&#10;      } catch (error) {&#10;        console.error('Failed to fetch exchange rates:', error)&#10;        this.setFallbackRates(base, symbols)&#10;      }&#10;    },&#10;&#10;    setFallbackRates(base: Currency, symbols: Currency[]) {&#10;      // Fallback exchange rates (approximate values)&#10;      const fallbackRates: Record&lt;string, Record&lt;string, number&gt;&gt; = {&#10;        EUR: { EUR: 1, USD: 1.09, CHF: 0.94, GBP: 0.84 },&#10;        USD: { EUR: 0.92, USD: 1, CHF: 0.86, GBP: 0.77 },&#10;        CHF: { EUR: 1.06, USD: 1.16, CHF: 1, GBP: 0.89 },&#10;        GBP: { EUR: 1.19, USD: 1.30, CHF: 1.12, GBP: 1 }&#10;      }&#10;&#10;      if (fallbackRates[base]) {&#10;        for (const symbol of symbols) {&#10;          if (fallbackRates[base][symbol]) {&#10;            this.fx[`${base}-&gt;${symbol}`] = fallbackRates[base][symbol]&#10;            this.fx[`${symbol}-&gt;${base}`] = 1 / fallbackRates[base][symbol]&#10;          }&#10;        }&#10;        this.base = base&#10;        console.log('Using fallback exchange rates')&#10;      }&#10;    },&#10;&#10;    async addGroup(name: string, members: PersonId[], currency: Currency) {&#10;      if (!this.currentUserId) throw new Error('User not authenticated')&#10;&#10;      try {&#10;        // Create group with members in one call&#10;        const groupId = await SupabaseService.createGroup(this.currentUserId, name, currency, members)&#10;&#10;        // Add to local state&#10;        this.groups.push({&#10;          id: groupId,&#10;          name,&#10;          members,&#10;          currency,&#10;          user_id: this.currentUserId,&#10;          created_at: new Date().toISOString()&#10;        })&#10;      } catch (error) {&#10;        console.error('Failed to add group:', error)&#10;        throw error&#10;      }&#10;    },&#10;&#10;    async renameGroup(id: string, name: string) {&#10;      if (!this.currentUserId) throw new Error('User not authenticated')&#10;&#10;      try {&#10;        await SupabaseService.updateGroup(id, this.currentUserId, { name })&#10;&#10;        const g = this.groups.find(g =&gt; g.id === id)&#10;        if (g) g.name = name&#10;      } catch (error) {&#10;        console.error('Failed to rename group:', error)&#10;        throw error&#10;      }&#10;    },&#10;&#10;    async setMembers(id: string, members: PersonId[]) {&#10;      if (!this.currentUserId) throw new Error('User not authenticated')&#10;&#10;      try {&#10;        await SupabaseService.updateGroupMembers(id, this.currentUserId, members)&#10;&#10;        const g = this.groups.find(g =&gt; g.id === id)&#10;        if (g) g.members = members&#10;      } catch (error) {&#10;        console.error('Failed to update members:', error)&#10;        throw error&#10;      }&#10;    },&#10;&#10;    async addExpense(e: Omit&lt;Expense,'id'&gt;) {&#10;      if (!this.currentUserId) throw new Error('User not authenticated')&#10;&#10;      try {&#10;        const expenseData = {&#10;          user_id: this.currentUserId,&#10;          group_id: e.groupId,&#10;          amount: e.amount,&#10;          payer: e.payer,&#10;          for_members: e.for,&#10;          note: e.note,&#10;          currency: e.currency&#10;        }&#10;&#10;        const expenseId = await SupabaseService.createExpense(expenseData)&#10;&#10;        // Add to local state&#10;        this.expenses.push({&#10;          ...e,&#10;          id: expenseId,&#10;          date: new Date().toISOString(),&#10;          user_id: this.currentUserId&#10;        })&#10;      } catch (error) {&#10;        console.error('Failed to add expense:', error)&#10;        throw error&#10;      }&#10;    },&#10;&#10;    async removeExpense(id: string) {&#10;      if (!this.currentUserId) throw new Error('User not authenticated')&#10;&#10;      try {&#10;        await SupabaseService.deleteExpense(id, this.currentUserId)&#10;        this.expenses = this.expenses.filter(e =&gt; e.id !== id)&#10;      } catch (error) {&#10;        console.error('Failed to remove expense:', error)&#10;        throw error&#10;      }&#10;    },&#10;&#10;    async resetAll() {&#10;      if (!this.currentUserId) throw new Error('User not authenticated')&#10;&#10;      try {&#10;        // Delete all groups (expenses will be cascade deleted)&#10;        for (const group of this.groups) {&#10;          await SupabaseService.deleteGroup(group.id, this.currentUserId)&#10;        }&#10;&#10;        this.groups = []&#10;        this.expenses = []&#10;      } catch (error) {&#10;        console.error('Failed to reset all data:', error)&#10;        throw error&#10;      }&#10;    }&#10;  }&#10;})" />
              <option name="updatedContent" value="import { defineStore } from 'pinia'&#10;import { SupabaseService } from '../lib/supabase-service'&#10;&#10;export type Currency = 'EUR' | 'USD' | 'CHF' | 'GBP'&#10;export type PersonId = string&#10;&#10;// Updated types to match Supabase schema&#10;export type Group = {&#10;  id: string&#10;  name: string&#10;  members: PersonId[]&#10;  currency: Currency&#10;  user_id?: string&#10;  created_at?: string&#10;}&#10;&#10;export type Expense = {&#10;  id: string&#10;  groupId: string&#10;  payer: PersonId&#10;  for: PersonId[]&#10;  amount: number&#10;  note?: string&#10;  date: string&#10;  currency?: Currency&#10;  user_id?: string&#10;}&#10;&#10;type State = {&#10;  groups: Group[]&#10;  expenses: Expense[]&#10;  fx: Record&lt;string, number&gt;&#10;  base: Currency&#10;  currentUserId: string | null&#10;  loading: boolean&#10;}&#10;&#10;export const useExpenseStore = defineStore('expenses', {&#10;  state: (): State =&gt; ({&#10;    groups: [],&#10;    expenses: [],&#10;    fx: {},&#10;    base: 'EUR',&#10;    currentUserId: null,&#10;    loading: false&#10;  }),&#10;&#10;  getters: {&#10;    groupById: (s) =&gt; (id: string) =&gt; s.groups.find(g =&gt; g.id === id),&#10;    balances: (s) =&gt; (groupId: string) =&gt; {&#10;      const g = s.groups.find(g =&gt; g.id === groupId)&#10;      if (!g) return {}&#10;&#10;      const bal: Record&lt;string, number&gt; = {}&#10;      g.members.forEach(m =&gt; bal[m] = 0)&#10;&#10;      s.expenses.filter(e =&gt; e.groupId === groupId).forEach(e =&gt; {&#10;        const eCur = e.currency || g.currency&#10;        const factor = (eCur === g.currency) ? 1 : (s.fx[`${eCur}-&gt;${g.currency}`] || 1)&#10;        const amt = e.amount * factor&#10;        const share = amt / e.for.length&#10;        bal[e.payer] += amt&#10;        e.for.forEach(m =&gt; bal[m] -= share)&#10;      })&#10;&#10;      Object.keys(bal).forEach(k =&gt; bal[k] = Math.round(bal[k]*100)/100)&#10;      return bal&#10;    },&#10;    settlements() {&#10;      return (groupId: string) =&gt; {&#10;        const b = { ...this.balances(groupId) } as Record&lt;string, number&gt;&#10;        const debtors = Object.entries(b).filter(([,v]) =&gt; v &lt; 0).sort((a,b)=&gt;a[1]-b[1])&#10;        const creditors = Object.entries(b).filter(([,v]) =&gt; v &gt; 0).sort((a,b)=&gt;b[1]-a[1])&#10;        const res: { from:PersonId; to:PersonId; amount:number }[] = []&#10;        let i=0,j=0&#10;&#10;        while (i&lt;debtors.length &amp;&amp; j&lt;creditors.length) {&#10;          const [dId, dAmt] = debtors[i]&#10;          const [cId, cAmt] = creditors[j]&#10;          const pay = Math.min(-dAmt, cAmt)&#10;          if (pay &gt; 0.005) res.push({ from:dId, to:cId, amount:Math.round(pay*100)/100 })&#10;          debtors[i][1] += pay&#10;          creditors[j][1] -= pay&#10;          if (Math.abs(debtors[i][1]) &lt; 1e-9) i++&#10;          if (Math.abs(creditors[j][1]) &lt; 1e-9) j++&#10;        }&#10;        return res&#10;      }&#10;    }&#10;  },&#10;&#10;  actions: {&#10;    async initialize() {&#10;      this.loading = true&#10;      try {&#10;        // Get current user ID (from Clerk or Supabase auth)&#10;        this.currentUserId = await this.getCurrentUserId()&#10;&#10;        if (this.currentUserId) {&#10;          // Load user data from Supabase&#10;          await this.loadUserData()&#10;        } else {&#10;          console.log('No authenticated user found, using empty state')&#10;          // Initialize with demo data if no user is authenticated&#10;          this.groups = [{&#10;            id: 'demo',&#10;            name: 'Beispielgruppe',&#10;            members: ['Alice', 'Bob', 'Clara'],&#10;            currency: 'EUR'&#10;          }]&#10;          this.expenses = []&#10;          this.fx = {}&#10;          this.base = 'EUR'&#10;        }&#10;      } catch (error) {&#10;        console.error('Failed to initialize store:', error)&#10;        // Fallback to demo data on error&#10;        this.groups = [{&#10;          id: 'demo',&#10;          name: 'Beispielgruppe',&#10;          members: ['Alice', 'Bob', 'Clara'],&#10;          currency: 'EUR'&#10;        }]&#10;        this.expenses = []&#10;        this.fx = {}&#10;        this.base = 'EUR'&#10;      } finally {&#10;        this.loading = false&#10;      }&#10;    },&#10;&#10;    async getCurrentUserId(): Promise&lt;string | null&gt; {&#10;      try {&#10;        // First try to get from Clerk&#10;        const clerk = (window as any).Clerk&#10;        if (clerk?.loaded &amp;&amp; clerk?.user?.id) {&#10;          console.log('Found Clerk user:', clerk.user.id)&#10;          return clerk.user.id&#10;        }&#10;&#10;        // Fallback to Supabase auth&#10;        const userId = await SupabaseService.getCurrentUserId()&#10;        if (userId) {&#10;          console.log('Found Supabase user:', userId)&#10;          return userId&#10;        }&#10;&#10;        console.log('No authenticated user found')&#10;        return null&#10;      } catch (error) {&#10;        console.error('Error getting user ID:', error)&#10;        return null&#10;      }&#10;    },&#10;&#10;    async loadUserData() {&#10;      if (!this.currentUserId) return&#10;&#10;      try {&#10;        // Load groups&#10;        const supabaseGroups = await SupabaseService.getGroups(this.currentUserId)&#10;        this.groups = supabaseGroups.map(g =&gt; ({&#10;          id: g.id,&#10;          name: g.name,&#10;          currency: g.currency as Currency,&#10;          members: g.members || [], // Now properly handled from database&#10;          user_id: g.user_id,&#10;          created_at: g.created_at&#10;        }))&#10;&#10;        // Load expenses for all groups&#10;        this.expenses = []&#10;        for (const group of this.groups) {&#10;          const groupExpenses = await SupabaseService.getExpenses(group.id)&#10;          this.expenses.push(...groupExpenses.map(e =&gt; ({&#10;            id: e.id,&#10;            groupId: e.group_id,&#10;            payer: e.payer,&#10;            for: e.for_members,&#10;            amount: e.amount,&#10;            note: e.note,&#10;            date: e.date,&#10;            currency: e.currency as Currency,&#10;            user_id: e.user_id&#10;          })))&#10;        }&#10;&#10;        // Load exchange rates&#10;        const ratesData = await SupabaseService.getExchangeRates(this.currentUserId)&#10;        if (ratesData) {&#10;          this.fx = ratesData.rates&#10;          this.base = ratesData.base as Currency&#10;        }&#10;      } catch (error) {&#10;        console.error('Failed to load user data:', error)&#10;      }&#10;    },&#10;&#10;    async refreshRates(base: Currency, symbols: Currency[]) {&#10;      try {&#10;        console.log(`Fetching exchange rates for ${base} -&gt; ${symbols.join(', ')}`)&#10;&#10;        // Use Hexarate API for each currency pair&#10;        for (const target of symbols) {&#10;          if (target === base) {&#10;            // Same currency, rate is 1&#10;            this.fx[`${base}-&gt;${target}`] = 1&#10;            this.fx[`${target}-&gt;${base}`] = 1&#10;            continue&#10;          }&#10;&#10;          try {&#10;            const apiUrl = `https://hexarate.paikama.co/api/rates/latest/${base}?target=${target}`&#10;            const resp = await fetch(apiUrl)&#10;&#10;            if (resp.ok) {&#10;              const result = await resp.json()&#10;              if (result.status_code === 200 &amp;&amp; result.data?.mid) {&#10;                const rate = result.data.mid&#10;                this.fx[`${base}-&gt;${target}`] = rate&#10;                this.fx[`${target}-&gt;${base}`] = 1 / rate&#10;                console.log(`✓ ${base}/${target}: ${rate}`)&#10;              }&#10;            } else {&#10;              console.warn(`Failed to fetch ${base}/${target} rate: ${resp.status}`)&#10;            }&#10;          } catch (error) {&#10;            console.warn(`Error fetching ${base}/${target} rate:`, error)&#10;          }&#10;        }&#10;&#10;        this.base = base&#10;        console.log('Exchange rates updated successfully from Hexarate API')&#10;&#10;        // Save to Supabase&#10;        if (this.currentUserId) {&#10;          try {&#10;            await SupabaseService.updateExchangeRates(this.currentUserId, this.fx, base)&#10;          } catch (error) {&#10;            console.error('Failed to save exchange rates:', error)&#10;          }&#10;        }&#10;&#10;        // If we didn't get any rates, fall back to static rates&#10;        const hasAnyRates = symbols.some(symbol =&gt; this.fx[`${base}-&gt;${symbol}`] !== undefined)&#10;        if (!hasAnyRates) {&#10;          console.warn('No exchange rates were fetched, using fallback rates')&#10;          this.setFallbackRates(base, symbols)&#10;        }&#10;&#10;      } catch (error) {&#10;        console.error('Failed to fetch exchange rates:', error)&#10;        this.setFallbackRates(base, symbols)&#10;      }&#10;    },&#10;&#10;    setFallbackRates(base: Currency, symbols: Currency[]) {&#10;      // Fallback exchange rates (approximate values)&#10;      const fallbackRates: Record&lt;string, Record&lt;string, number&gt;&gt; = {&#10;        EUR: { EUR: 1, USD: 1.09, CHF: 0.94, GBP: 0.84 },&#10;        USD: { EUR: 0.92, USD: 1, CHF: 0.86, GBP: 0.77 },&#10;        CHF: { EUR: 1.06, USD: 1.16, CHF: 1, GBP: 0.89 },&#10;        GBP: { EUR: 1.19, USD: 1.30, CHF: 1.12, GBP: 1 }&#10;      }&#10;&#10;      if (fallbackRates[base]) {&#10;        for (const symbol of symbols) {&#10;          if (fallbackRates[base][symbol]) {&#10;            this.fx[`${base}-&gt;${symbol}`] = fallbackRates[base][symbol]&#10;            this.fx[`${symbol}-&gt;${base}`] = 1 / fallbackRates[base][symbol]&#10;          }&#10;        }&#10;        this.base = base&#10;        console.log('Using fallback exchange rates')&#10;      }&#10;    },&#10;&#10;    async addGroup(name: string, members: PersonId[], currency: Currency) {&#10;      if (!this.currentUserId) throw new Error('User not authenticated')&#10;&#10;      try {&#10;        // Create group with members in one call&#10;        const groupId = await SupabaseService.createGroup(this.currentUserId, name, currency, members)&#10;&#10;        // Add to local state&#10;        this.groups.push({&#10;          id: groupId,&#10;          name,&#10;          members,&#10;          currency,&#10;          user_id: this.currentUserId,&#10;          created_at: new Date().toISOString()&#10;        })&#10;      } catch (error) {&#10;        console.error('Failed to add group:', error)&#10;        throw error&#10;      }&#10;    },&#10;&#10;    async renameGroup(id: string, name: string) {&#10;      if (!this.currentUserId) throw new Error('User not authenticated')&#10;&#10;      try {&#10;        await SupabaseService.updateGroup(id, this.currentUserId, { name })&#10;&#10;        const g = this.groups.find(g =&gt; g.id === id)&#10;        if (g) g.name = name&#10;      } catch (error) {&#10;        console.error('Failed to rename group:', error)&#10;        throw error&#10;      }&#10;    },&#10;&#10;    async setMembers(id: string, members: PersonId[]) {&#10;      if (!this.currentUserId) throw new Error('User not authenticated')&#10;&#10;      try {&#10;        await SupabaseService.updateGroupMembers(id, this.currentUserId, members)&#10;&#10;        const g = this.groups.find(g =&gt; g.id === id)&#10;        if (g) g.members = members&#10;      } catch (error) {&#10;        console.error('Failed to update members:', error)&#10;        throw error&#10;      }&#10;    },&#10;&#10;    async deleteGroup(id: string) {&#10;      if (!this.currentUserId) throw new Error('User not authenticated')&#10;&#10;      try {&#10;        await SupabaseService.deleteGroup(id, this.currentUserId)&#10;&#10;        // Remove group and its expenses from local state&#10;        this.groups = this.groups.filter(g =&gt; g.id !== id)&#10;        this.expenses = this.expenses.filter(e =&gt; e.groupId !== id)&#10;      } catch (error) {&#10;        console.error('Failed to delete group:', error)&#10;        throw error&#10;      }&#10;    },&#10;&#10;    async addExpense(e: Omit&lt;Expense,'id'&gt;) {&#10;      if (!this.currentUserId) throw new Error('User not authenticated')&#10;&#10;      try {&#10;        const expenseData = {&#10;          user_id: this.currentUserId,&#10;          group_id: e.groupId,&#10;          amount: e.amount,&#10;          payer: e.payer,&#10;          for_members: e.for,&#10;          note: e.note,&#10;          currency: e.currency&#10;        }&#10;&#10;        const expenseId = await SupabaseService.createExpense(expenseData)&#10;&#10;        // Add to local state&#10;        this.expenses.push({&#10;          ...e,&#10;          id: expenseId,&#10;          date: new Date().toISOString(),&#10;          user_id: this.currentUserId&#10;        })&#10;      } catch (error) {&#10;        console.error('Failed to add expense:', error)&#10;        throw error&#10;      }&#10;    },&#10;&#10;    async removeExpense(id: string) {&#10;      if (!this.currentUserId) throw new Error('User not authenticated')&#10;&#10;      try {&#10;        await SupabaseService.deleteExpense(id, this.currentUserId)&#10;        this.expenses = this.expenses.filter(e =&gt; e.id !== id)&#10;      } catch (error) {&#10;        console.error('Failed to remove expense:', error)&#10;        throw error&#10;      }&#10;    },&#10;&#10;    async resetAll() {&#10;      if (!this.currentUserId) throw new Error('User not authenticated')&#10;&#10;      try {&#10;        // Delete all groups (expenses will be cascade deleted)&#10;        for (const group of this.groups) {&#10;          await SupabaseService.deleteGroup(group.id, this.currentUserId)&#10;        }&#10;&#10;        this.groups = []&#10;        this.expenses = []&#10;      } catch (error) {&#10;        console.error('Failed to reset all data:', error)&#10;        throw error&#10;      }&#10;    }&#10;  }&#10;})" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/vercel.json">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/vercel.json" />
              <option name="originalContent" value="{&#10;  &quot;functions&quot;: {&#10;    &quot;api/**/*.ts&quot;: {&#10;      &quot;runtime&quot;: &quot;@vercel/node@3.0.7&quot;&#10;    }&#10;  },&#10;  &quot;build&quot;: {&#10;    &quot;env&quot;: {&#10;      &quot;VITE_SUPABASE_URL&quot;: &quot;https://fedgovdtnecuwywkveou.supabase.co&quot;,&#10;      &quot;VITE_SUPABASE_ANON_KEY&quot;: &quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZlZGdvdmR0bmVjdXd5d2t2ZW91Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQ2NjU5NjMsImV4cCI6MjA3MDI0MTk2M30.0VJu25tU_EoyZxuZnEfgwW05jX8lJZtWawlV3cI_5eE&quot;&#10;    }&#10;  },&#10;  &quot;buildCommand&quot;: &quot;pnpm run build&quot;,&#10;  &quot;installCommand&quot;: &quot;pnpm install&quot;,&#10;  &quot;outputDirectory&quot;: &quot;dist&quot;,&#10;  &quot;nodeVersion&quot;: &quot;18.x&quot;&#10;  &quot;nodeVersion&quot;: &quot;18.x&quot;&#10;  &quot;nodeVersion&quot;: &quot;18.x&quot;&#10;  &quot;nodeVersion&quot;: &quot;18.x&quot;&#10;}&#10;" />
              <option name="updatedContent" value="{&#10;  &quot;functions&quot;: {&#10;    &quot;api/**/*.ts&quot;: {&#10;      &quot;runtime&quot;: &quot;@vercel/node@3.0.7&quot;&#10;    }&#10;  },&#10;  &quot;build&quot;: {&#10;    &quot;env&quot;: {&#10;      &quot;VITE_SUPABASE_URL&quot;: &quot;https://fedgovdtnecuwywkveou.supabase.co&quot;,&#10;      &quot;VITE_SUPABASE_ANON_KEY&quot;: &quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZlZGdvdmR0bmVjdXd5d2t2ZW91Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQ2NjU5NjMsImV4cCI6MjA3MDI0MTk2M30.0VJu25tU_EoyZxuZnEfgwW05jX8lJZtWawlV3cI_5eE&quot;&#10;    }&#10;  },&#10;  &quot;buildCommand&quot;: &quot;pnpm run build&quot;,&#10;  &quot;installCommand&quot;: &quot;pnpm install&quot;,&#10;  &quot;outputDirectory&quot;: &quot;dist&quot;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/vite.config.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/vite.config.ts" />
              <option name="originalContent" value="import { defineConfig } from 'vite'&#10;import vue from '@vitejs/plugin-vue'&#10;&#10;export default defineConfig({&#10;  plugins: [vue()],&#10;  server: { port: 5173 }&#10;&#10;&#10;" />
              <option name="updatedContent" value="import { defineConfig } from 'vite'&#10;import vue from '@vitejs/plugin-vue'&#10;&#10;export default defineConfig({&#10;  plugins: [vue()],&#10;  server: { &#10;    port: 5173,&#10;    proxy: {&#10;      '/api': {&#10;        target: 'http://localhost:3000',&#10;        changeOrigin: true,&#10;        rewrite: (path) =&gt; path.replace(/^\/api/, '/api')&#10;      }&#10;    }&#10;  },&#10;  define: {&#10;    // Expose environment variables to the client&#10;    __SUPABASE_URL__: JSON.stringify(process.env.VITE_SUPABASE_URL),&#10;    __SUPABASE_ANON_KEY__: JSON.stringify(process.env.VITE_SUPABASE_ANON_KEY),&#10;  }&#10;})" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>